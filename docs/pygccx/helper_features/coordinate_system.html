<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygccx.helper_features.coordinate_system API documentation</title>
<meta name="description" content="Copyright Matthias Sedlmaier 2022
This file is part of pygccx …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygccx.helper_features.coordinate_system</code></h1>
</header>
<section id="section-intro">
<p>Copyright Matthias Sedlmaier 2022
This file is part of pygccx.</p>
<p>pygccx is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.</p>
<p>pygccx is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with pygccx.<br>
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Copyright Matthias Sedlmaier 2022
This file is part of pygccx.

pygccx is free software: you can redistribute it 
and/or modify it under the terms of the GNU General Public License as 
published by the Free Software Foundation, either version 3 of the 
License, or (at your option) any later version.

pygccx is distributed in the hope that it will 
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pygccx.  
If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#39;&#39;&#39;

from dataclasses import dataclass, field, InitVar, replace
from typing import Sequence, Optional

from pygccx.enums import EOrientationSystems
from pygccx.protocols import number

import numpy as np
import numpy.typing as npt
from scipy.spatial.transform import Rotation
@dataclass
class CoordinateSystem:
    &#34;&#34;&#34;
    Class representing a local coordinate system.

    Objects of this class can be used to instantiate an Orientation or a Transform
    or to convert results (displacements, stresses, ...) from the global system.

    Args:
        name: Name of this coordinate system. Used if an Orientation or Transform is
            instantiated using this coordinate system.
        type: Optional. Type of this coordinate system. Default is RECTANGULAR
        origin: Optional. Origin of this coordinate system Default is (0.,0.,0.)
        matrix: Optional. Orientation matrix of this coordinate system. 
            Default is same as global system
    &#34;&#34;&#34;
    name:str
    type:EOrientationSystems = EOrientationSystems.RECTANGULAR
    origin:InitVar[Sequence[number]|npt.NDArray] = (0.,0.,0.)
    matrix:InitVar[Sequence[Sequence[number]]|npt.NDArray] = ((1.,0.,0.), (0.,1.,0.), (0.,0.,1.))

    _origin:npt.NDArray[np.float_] = field(init=False)
    _matrix:npt.NDArray[np.float_]   = field(init=False)

    def __post_init__(self, origin, matrix):
        self.set_origin(origin)
        self.set_matrix(matrix)

    def get_origin(self) -&gt; npt.NDArray:
        &#34;&#34;&#34;Gets the origin of this coordinate system as 1D numpy array&#34;&#34;&#34;
        return self._origin

    def set_origin(self, origin:Sequence[number]|npt.NDArray):
        &#34;&#34;&#34;
        Sets the origin of this coordinate system.

        Args:
            origin (Sequence[number]): New origin. Must be in the form [x,y,z]

        Raises:
            ValueError: Raised if length of origin is not 3
        &#34;&#34;&#34;
        if len(origin) != 3:
            raise ValueError(f&#39;origin must have a length of 3, got {len(origin)}&#39;)
        self._origin = np.array(origin, dtype=float)

    def get_matrix(self) -&gt; npt.NDArray:
        &#34;&#34;&#34;Gets the orientation matrix of this coordinate system as 2D numpy array.
        row 0: vector of x axis in global system
        row 1: vector of y axis in global system
        row 2: vector of z axis in global system
        &#34;&#34;&#34;
        return self._matrix

    def set_matrix(self, matrix:Sequence[Sequence[number]]|npt.NDArray):
        &#34;&#34;&#34;
        Sets the orientation matrix of this coordinate system.
 
        Args:
            matrix (Sequence[Sequence[number]]): New matrix. Must be in the form 
                                                 [[nxx,nxy,nxz],[nyx,nyy,nyz],[nzx,nzy,nzz]]
                                                 row 0: vector of x axis in global system
                                                 row 1: vector of y axis in global system
                                                 row 2: vector of z axis in global system

        Raises:
            ValueError: Raised if number of rows id not 3
            ValueError: Raised if length of each row is not 3
        &#34;&#34;&#34;
        if len(matrix) != 3:
            raise ValueError(f&#39;matrix must have a length of 3, got {len(matrix)}&#39;)
        if not all(len(r) == 3 for r in matrix):
            raise ValueError(f&#39;Each row in matrix must have a length of 3&#39;)
        self._matrix = np.array(matrix, dtype=float)

    def move(self, v_inc:Sequence[number]|npt.NDArray):
        &#34;&#34;&#34;
        Moves the origin by the incrementation vector v_inc.

        Args:
            v_inc (Sequence[number]|npt.NDArray): Incrementation vector in the form [dx, dy, dz]

        Raises:
            ValueError: Raised if length of v_inc is not 3
        &#34;&#34;&#34;
        if len(v_inc) != 3:
            raise ValueError(f&#39;v_inc must have a length of 3, got {len(v_inc)}&#39;)
        self._origin += np.array(v_inc, dtype=float)

    def copy(self) -&gt; &#39;CoordinateSystem&#39;: 
        &#34;&#34;&#34;Returns an independant copy of this coordinate system&#34;&#34;&#34;    
        return replace(self, origin=self._origin, matrix=self._matrix)
    
    def rotate_x(self, ang:number, degrees:bool=False):
        &#34;&#34;&#34;
        Rotates this coordinate system about its x-axis by the given angle.

        Args:
            ang (number): Rotation angle 
            degrees (bool): Flag if ang is given in deg. Default = False
        &#34;&#34;&#34;
        self._rotate(0, ang, degrees)

    def rotate_y(self, ang:number, degrees:bool=False):
        &#34;&#34;&#34;
        Rotates this coordinate system about its y-axis by the given angle.

        Args:
            ang (number): Rotation angle 
            degrees (bool): Flag if ang is given in deg. Default = False
        &#34;&#34;&#34;
        self._rotate(1, ang, degrees)

    def rotate_z(self, ang:number, degrees:bool=False):
        &#34;&#34;&#34;
        Rotates this coordinate system about its z-axis by the given angle.

        Args:
            ang (number): Rotation angle 
            degrees (bool): Flag if ang is given in deg. Default = False
        &#34;&#34;&#34;
        self._rotate(2, ang, degrees)

    def transform_point_from_global(self, point:npt.ArrayLike) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given global cartesian point coordinates into this system and
        returns the new coordinates.

        If this system is cartesian, cartesian coordinates 
        [x&#39;, y&#39;, z&#39;] are returned.
        If this system is cylindrical, polar coordinates 
        [r&#39;, theta&#39;(rad), z&#39;] are returned

        Args:
            points (npt.ArrayLike): 
                Global cartesian coordinates [x1,y1,z1]
                of point to transform  

        Returns:
            np.ndarray: Local coordinates [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;, z&#39;].
        &#34;&#34;&#34;

        pnt = np.array(point, dtype=float)
        if pnt.shape != (3,):
            raise ValueError(f&#34;Shape of point must be (3,), got {pnt.shape}&#34;)
        
        pnt -= self._origin
        pnt = self._matrix @ pnt

        if self.type == EOrientationSystems.CYLINDRICAL: 
            pnt[0], pnt[1] = (np.hypot(pnt[0], pnt[1]),
                                    np.arctan2(pnt[1], pnt[0]))

        return pnt

    def transform_point_to_global(self, point:npt.ArrayLike) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local point coordinates into the global system and
        returns the new coordinates.

        If this system is cartesian, points must contain local cartesian coordinates 
        [x&#39;, y&#39;, z&#39;].
        If this system is cylindrical, points must contain local cylindrical coordinates
        [r&#39;, theta&#39;(rad), z&#39;].

        Args:
            points (npt.ArrayLike): 
                local cartesian or cylindriacl coordinates 
                [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;(rad), z&#39;]
                of points to transform  

        Returns:
            np.ndarray: global cartesian coordinates [x, y, z].
        &#34;&#34;&#34;

        pnt = np.array(point, dtype=float)
        if pnt.shape != (3,):
            raise ValueError(f&#34;Shape of point must be (3,), got {pnt.shape}&#34;)
        
        if self.type == EOrientationSystems.CYLINDRICAL:
            pnt[0], pnt[1] = (np.cos(pnt[1]) * pnt[0],
                                    np.sin(pnt[1]) * pnt[0])
            
        pnts = self._matrix.T @ pnt
        pnts += self._origin

        return pnts

    def transform_point_to_other(self, point:npt.ArrayLike, other:&#39;CoordinateSystem&#39;) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given point coordinates from this system into an other
        system and returns the new coordinates.

        If this system is cartesian, points must contain local cartesian coordinates 
        [x&#39;, y&#39;, z&#39;].
        If this system is cylindrical, points must contain local cylindrical coordinates
        [r&#39;, theta&#39;(rad), z&#39;].

        If other system is cartesian, cartesian coordinates 
        [x&#39;&#39;, y&#39;&#39;, z&#39;&#39;] are returned.
        If other system is cylindrical, polar coordinates 
        [[r&#39;&#39;, theta&#39;&#39;(rad), z&#39;&#39;], ...] are returned

        Args:
            point (npt.ArrayLike): 
                Local coordinates [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;, z&#39;] of points to transform

        Returns:
            np.ndarray: Local coordinates [x&#39;&#39;,y&#39;&#39;,z&#39;&#39;] or [r&#39;&#39;, theta&#39;&#39;, z&#39;&#39;].
        &#34;&#34;&#34;
        return other.transform_point_from_global(
                   self.transform_point_to_global(point)
                   )

    def transform_vector_from_global(self, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given global vector into this system and returns it.

        If this system is cartesian, the vector is rotated into it and returned. 
        No ref_point is needed.

        If this system is cylindrical, the returned components are:
        vx&#39;: Radial component in this system at the location of ref_point.
        vy&#39;: tangential component in this system at the location of ref_point.
        vz&#39;: axial component in this system.

        Args:
            vector (npt.ArrayLike): 
                Global cartesian vector [vx, vy, vz] to transform.
            ref_point (npt.ArrayLike|None): 
                Reference point in global system, at which the vector is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Local vector [vx&#39;, vy&#39;, vz&#39;].
        &#34;&#34;&#34;

        vec = np.array(vector, dtype=float)
        if vec.shape != (3,):
            raise ValueError(f&#34;Shape of vector must be (3,), got {vec.shape}&#34;)

        if self.type == EOrientationSystems.CYLINDRICAL: 
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point, dtype=float)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
           
            phi = self.transform_point_from_global(ref_pnt)[1]
            c = self.copy()
            c.rotate_z(phi)
            return c._matrix @ vec 

        vec = self._matrix @ vec
        return vec

    def transform_vector_to_global(self, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local vector from this system into the global and returns it.

        If this system is cartesian, the vector is rotated into global and returned. 
        No ref_point is needed.

        If this system is cylindrical, the reference point at which the vector is acting, 
        is required.

        Args:
            vector (npt.ArrayLike): 
                Local vector [vx&#39;, vy&#39;, vz&#39;] to transform.
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the vector is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Global vector [vx, vy, vz].
        &#34;&#34;&#34;
        vec = np.array(vector, dtype=float)
        if vec.shape != (3,):
            raise ValueError(f&#34;Shape of vector must be (3,), got {vec.shape}&#34;)
        
        if self.type == EOrientationSystems.CYLINDRICAL:
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
            
            phi = ref_pnt[1]
            c = self.copy()
            c.rotate_z(phi)
            return c._matrix.T @ vec 

        vec = self._matrix.T @ vec
        return vec

    def transform_vector_to_other(self, other:&#39;CoordinateSystem&#39;, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local vector into an other system and returns it.

        Args:
            other (CoordinateSystem): 
                The system to which the vector should be transformed.
            vector (npt.ArrayLike): 
                Local vector [x&#39;,y&#39;,z&#39;] to transform
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the vector is acting.
                Only required if this system OR the other is CYLINCRICAL.

        Returns:
            np.ndarray: Local vector [vx&#39;&#39;,vy&#39;&#39;,vz&#39;&#39;] in other system.
        &#34;&#34;&#34;

        if (self.type == EOrientationSystems.CYLINDRICAL or 
            other.type == EOrientationSystems.CYLINDRICAL):
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if this or other system is CYLINDRICAL&#34;)
            
            return other.transform_vector_from_global(
                        self.transform_vector_to_global(vector, ref_point),
                        self.transform_point_to_global(ref_point)
                    )
        # self and other are rectangular
        return other.transform_vector_from_global(
                    self.transform_vector_to_global(vector)
                )

    def transform_tensor_from_global(self, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given global tensor into this system and returns it.

        If this system is cartesian, the tensor is rotated into it and returned. 
        No ref_point is needed.

        The tensor can be either given as a vector with six components
        [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
        or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

        If this system is cylindrical, the returned components are:
        txx&#39;: Radial component in this system at the location of ref_point.
        tyy&#39;: tangential component in this system at the location of ref_point.
        tzz&#39;: axial component in this system.
        txy&#39;, tyz&#39;, txz&#39;: corresponding deviatorivc components

        Args:
            tensor (npt.ArrayLike): 
                Global cartesian tensor to transform. Of shape (6,) or (3,3)
            ref_point (npt.ArrayLike|None): 
                Reference point in global system, at which the tensor is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Local transformed tensor, same shape as given tensor.
        &#34;&#34;&#34;
        t, out_shape = self._2matrix(tensor)
        
        if self.type == EOrientationSystems.CYLINDRICAL:
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point, dtype=float)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
           
            phi = self.transform_point_from_global(ref_pnt)[1]
            c = self.copy()
            c.rotate_z(phi)
            t = c._matrix @ t @ c._matrix.T
            return self._2outshape(t, out_shape)

        t = self._matrix @ t @ self._matrix.T
        return self._2outshape(t, out_shape)

    def transform_tensor_to_global(self, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local tensor from this system into the global and returns it.

        If this system is cartesian, the tensor is rotated into global and returned. 
        No ref_point is needed.

        The tensor can be either given as a vector with six components
        [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
        or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

        If this system is cylindrical, the reference point at which the tensor is acting, 
        is required.

        Args:
            tensor (npt.ArrayLike): 
                Local tensor to transform. Of shape (6,) or (3,3)
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the tensor is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Global tensor, same shape as given tensor.
        &#34;&#34;&#34;
        t, out_shape = self._2matrix(tensor)

        if self.type == EOrientationSystems.CYLINDRICAL:
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point, dtype=float)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
            
            phi = ref_pnt[1]
            c = self.copy()
            c.rotate_z(phi)
            t = c._matrix.T @ t @ c._matrix
            return self._2outshape(t, out_shape)
        
        t = self._matrix.T @ t @ self._matrix
        return self._2outshape(t, out_shape)

    def transform_tensor_to_other(self, other:&#39;CoordinateSystem&#39;, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local tensor into an other system and returns it.

        The tensor can be either given as a vector with six components
        [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
        or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

        Args:
            other (CoordinateSystem): 
                The system to which the vector should be transformed.
            tensor (npt.ArrayLike): 
                Local tensor to transform. Of shape (6,) or (3,3)
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the tensor is acting.
                Only required if this system OR the other is CYLINCRICAL.

        Returns:
            np.ndarray: Local vector in other system. Same shape as given tensor
        &#34;&#34;&#34;
        if (self.type == EOrientationSystems.CYLINDRICAL or 
            other.type == EOrientationSystems.CYLINDRICAL):
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if this or other system is CYLINDRICAL&#34;)
            
            return other.transform_tensor_from_global(
                        self.transform_tensor_to_global(tensor, ref_point),
                        self.transform_point_to_global(ref_point)
                    )
        # self and other are rectangular
        return other.transform_tensor_from_global(
                    self.transform_tensor_to_global(tensor)
                )


    def _rotate(self, axis:int, ang:number, degrees:bool):

        rot_axis = self._matrix[axis]
        rot_ang = np.deg2rad(ang) if degrees else ang
        r = Rotation.from_rotvec(rot_axis * rot_ang)
        self._matrix = r.apply(self._matrix)

    def _2matrix(self, tensor:npt.ArrayLike) -&gt; tuple[np.ndarray, tuple[int,...]]:

        t = np.array(tensor, dtype=float)
        if t.shape == (6,):
            xx, yy, zz, xy, yz, zx = t
            return np.array([[xx, xy, zx],
                             [xy, yy, yz],
                             [zx, yz, zz]]), t.shape
        
        if t.shape == (3,3):
            return t, t.shape
        
        raise ValueError(f&#34;Shape of tensor must be (6,) or (3,3), got {t.shape}&#34;)

    def _2outshape(self, matrix:np.ndarray, out_shape:tuple[int,...]) -&gt; np.ndarray:
        if out_shape == (3,3):
            return matrix
        if out_shape == (6,):
            m = matrix
            return np.array([m[0,0], m[1,1], m[2,2], m[0,1], m[1,2], m[0,2]])
        
        raise ValueError(f&#34;out_shape must be (6,) or (3,3), got {out_shape}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem"><code class="flex name class">
<span>class <span class="ident">CoordinateSystem</span></span>
<span>(</span><span>name: str, type: <a title="pygccx.enums.EOrientationSystems" href="../enums.html#pygccx.enums.EOrientationSystems">EOrientationSystems</a> = EOrientationSystems.RECTANGULAR, origin: dataclasses.InitVar[typing.Union[typing.Sequence[int | float | numpy.number], numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]]] = (0.0, 0.0, 0.0), matrix: dataclasses.InitVar[typing.Union[typing.Sequence[typing.Sequence[int | float | numpy.number]], numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]]] = ((1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a local coordinate system.</p>
<p>Objects of this class can be used to instantiate an Orientation or a Transform
or to convert results (displacements, stresses, &hellip;) from the global system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of this coordinate system. Used if an Orientation or Transform is
instantiated using this coordinate system.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Optional. Type of this coordinate system. Default is RECTANGULAR</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>Optional. Origin of this coordinate system Default is (0.,0.,0.)</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Optional. Orientation matrix of this coordinate system.
Default is same as global system</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CoordinateSystem:
    &#34;&#34;&#34;
    Class representing a local coordinate system.

    Objects of this class can be used to instantiate an Orientation or a Transform
    or to convert results (displacements, stresses, ...) from the global system.

    Args:
        name: Name of this coordinate system. Used if an Orientation or Transform is
            instantiated using this coordinate system.
        type: Optional. Type of this coordinate system. Default is RECTANGULAR
        origin: Optional. Origin of this coordinate system Default is (0.,0.,0.)
        matrix: Optional. Orientation matrix of this coordinate system. 
            Default is same as global system
    &#34;&#34;&#34;
    name:str
    type:EOrientationSystems = EOrientationSystems.RECTANGULAR
    origin:InitVar[Sequence[number]|npt.NDArray] = (0.,0.,0.)
    matrix:InitVar[Sequence[Sequence[number]]|npt.NDArray] = ((1.,0.,0.), (0.,1.,0.), (0.,0.,1.))

    _origin:npt.NDArray[np.float_] = field(init=False)
    _matrix:npt.NDArray[np.float_]   = field(init=False)

    def __post_init__(self, origin, matrix):
        self.set_origin(origin)
        self.set_matrix(matrix)

    def get_origin(self) -&gt; npt.NDArray:
        &#34;&#34;&#34;Gets the origin of this coordinate system as 1D numpy array&#34;&#34;&#34;
        return self._origin

    def set_origin(self, origin:Sequence[number]|npt.NDArray):
        &#34;&#34;&#34;
        Sets the origin of this coordinate system.

        Args:
            origin (Sequence[number]): New origin. Must be in the form [x,y,z]

        Raises:
            ValueError: Raised if length of origin is not 3
        &#34;&#34;&#34;
        if len(origin) != 3:
            raise ValueError(f&#39;origin must have a length of 3, got {len(origin)}&#39;)
        self._origin = np.array(origin, dtype=float)

    def get_matrix(self) -&gt; npt.NDArray:
        &#34;&#34;&#34;Gets the orientation matrix of this coordinate system as 2D numpy array.
        row 0: vector of x axis in global system
        row 1: vector of y axis in global system
        row 2: vector of z axis in global system
        &#34;&#34;&#34;
        return self._matrix

    def set_matrix(self, matrix:Sequence[Sequence[number]]|npt.NDArray):
        &#34;&#34;&#34;
        Sets the orientation matrix of this coordinate system.
 
        Args:
            matrix (Sequence[Sequence[number]]): New matrix. Must be in the form 
                                                 [[nxx,nxy,nxz],[nyx,nyy,nyz],[nzx,nzy,nzz]]
                                                 row 0: vector of x axis in global system
                                                 row 1: vector of y axis in global system
                                                 row 2: vector of z axis in global system

        Raises:
            ValueError: Raised if number of rows id not 3
            ValueError: Raised if length of each row is not 3
        &#34;&#34;&#34;
        if len(matrix) != 3:
            raise ValueError(f&#39;matrix must have a length of 3, got {len(matrix)}&#39;)
        if not all(len(r) == 3 for r in matrix):
            raise ValueError(f&#39;Each row in matrix must have a length of 3&#39;)
        self._matrix = np.array(matrix, dtype=float)

    def move(self, v_inc:Sequence[number]|npt.NDArray):
        &#34;&#34;&#34;
        Moves the origin by the incrementation vector v_inc.

        Args:
            v_inc (Sequence[number]|npt.NDArray): Incrementation vector in the form [dx, dy, dz]

        Raises:
            ValueError: Raised if length of v_inc is not 3
        &#34;&#34;&#34;
        if len(v_inc) != 3:
            raise ValueError(f&#39;v_inc must have a length of 3, got {len(v_inc)}&#39;)
        self._origin += np.array(v_inc, dtype=float)

    def copy(self) -&gt; &#39;CoordinateSystem&#39;: 
        &#34;&#34;&#34;Returns an independant copy of this coordinate system&#34;&#34;&#34;    
        return replace(self, origin=self._origin, matrix=self._matrix)
    
    def rotate_x(self, ang:number, degrees:bool=False):
        &#34;&#34;&#34;
        Rotates this coordinate system about its x-axis by the given angle.

        Args:
            ang (number): Rotation angle 
            degrees (bool): Flag if ang is given in deg. Default = False
        &#34;&#34;&#34;
        self._rotate(0, ang, degrees)

    def rotate_y(self, ang:number, degrees:bool=False):
        &#34;&#34;&#34;
        Rotates this coordinate system about its y-axis by the given angle.

        Args:
            ang (number): Rotation angle 
            degrees (bool): Flag if ang is given in deg. Default = False
        &#34;&#34;&#34;
        self._rotate(1, ang, degrees)

    def rotate_z(self, ang:number, degrees:bool=False):
        &#34;&#34;&#34;
        Rotates this coordinate system about its z-axis by the given angle.

        Args:
            ang (number): Rotation angle 
            degrees (bool): Flag if ang is given in deg. Default = False
        &#34;&#34;&#34;
        self._rotate(2, ang, degrees)

    def transform_point_from_global(self, point:npt.ArrayLike) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given global cartesian point coordinates into this system and
        returns the new coordinates.

        If this system is cartesian, cartesian coordinates 
        [x&#39;, y&#39;, z&#39;] are returned.
        If this system is cylindrical, polar coordinates 
        [r&#39;, theta&#39;(rad), z&#39;] are returned

        Args:
            points (npt.ArrayLike): 
                Global cartesian coordinates [x1,y1,z1]
                of point to transform  

        Returns:
            np.ndarray: Local coordinates [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;, z&#39;].
        &#34;&#34;&#34;

        pnt = np.array(point, dtype=float)
        if pnt.shape != (3,):
            raise ValueError(f&#34;Shape of point must be (3,), got {pnt.shape}&#34;)
        
        pnt -= self._origin
        pnt = self._matrix @ pnt

        if self.type == EOrientationSystems.CYLINDRICAL: 
            pnt[0], pnt[1] = (np.hypot(pnt[0], pnt[1]),
                                    np.arctan2(pnt[1], pnt[0]))

        return pnt

    def transform_point_to_global(self, point:npt.ArrayLike) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local point coordinates into the global system and
        returns the new coordinates.

        If this system is cartesian, points must contain local cartesian coordinates 
        [x&#39;, y&#39;, z&#39;].
        If this system is cylindrical, points must contain local cylindrical coordinates
        [r&#39;, theta&#39;(rad), z&#39;].

        Args:
            points (npt.ArrayLike): 
                local cartesian or cylindriacl coordinates 
                [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;(rad), z&#39;]
                of points to transform  

        Returns:
            np.ndarray: global cartesian coordinates [x, y, z].
        &#34;&#34;&#34;

        pnt = np.array(point, dtype=float)
        if pnt.shape != (3,):
            raise ValueError(f&#34;Shape of point must be (3,), got {pnt.shape}&#34;)
        
        if self.type == EOrientationSystems.CYLINDRICAL:
            pnt[0], pnt[1] = (np.cos(pnt[1]) * pnt[0],
                                    np.sin(pnt[1]) * pnt[0])
            
        pnts = self._matrix.T @ pnt
        pnts += self._origin

        return pnts

    def transform_point_to_other(self, point:npt.ArrayLike, other:&#39;CoordinateSystem&#39;) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given point coordinates from this system into an other
        system and returns the new coordinates.

        If this system is cartesian, points must contain local cartesian coordinates 
        [x&#39;, y&#39;, z&#39;].
        If this system is cylindrical, points must contain local cylindrical coordinates
        [r&#39;, theta&#39;(rad), z&#39;].

        If other system is cartesian, cartesian coordinates 
        [x&#39;&#39;, y&#39;&#39;, z&#39;&#39;] are returned.
        If other system is cylindrical, polar coordinates 
        [[r&#39;&#39;, theta&#39;&#39;(rad), z&#39;&#39;], ...] are returned

        Args:
            point (npt.ArrayLike): 
                Local coordinates [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;, z&#39;] of points to transform

        Returns:
            np.ndarray: Local coordinates [x&#39;&#39;,y&#39;&#39;,z&#39;&#39;] or [r&#39;&#39;, theta&#39;&#39;, z&#39;&#39;].
        &#34;&#34;&#34;
        return other.transform_point_from_global(
                   self.transform_point_to_global(point)
                   )

    def transform_vector_from_global(self, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given global vector into this system and returns it.

        If this system is cartesian, the vector is rotated into it and returned. 
        No ref_point is needed.

        If this system is cylindrical, the returned components are:
        vx&#39;: Radial component in this system at the location of ref_point.
        vy&#39;: tangential component in this system at the location of ref_point.
        vz&#39;: axial component in this system.

        Args:
            vector (npt.ArrayLike): 
                Global cartesian vector [vx, vy, vz] to transform.
            ref_point (npt.ArrayLike|None): 
                Reference point in global system, at which the vector is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Local vector [vx&#39;, vy&#39;, vz&#39;].
        &#34;&#34;&#34;

        vec = np.array(vector, dtype=float)
        if vec.shape != (3,):
            raise ValueError(f&#34;Shape of vector must be (3,), got {vec.shape}&#34;)

        if self.type == EOrientationSystems.CYLINDRICAL: 
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point, dtype=float)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
           
            phi = self.transform_point_from_global(ref_pnt)[1]
            c = self.copy()
            c.rotate_z(phi)
            return c._matrix @ vec 

        vec = self._matrix @ vec
        return vec

    def transform_vector_to_global(self, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local vector from this system into the global and returns it.

        If this system is cartesian, the vector is rotated into global and returned. 
        No ref_point is needed.

        If this system is cylindrical, the reference point at which the vector is acting, 
        is required.

        Args:
            vector (npt.ArrayLike): 
                Local vector [vx&#39;, vy&#39;, vz&#39;] to transform.
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the vector is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Global vector [vx, vy, vz].
        &#34;&#34;&#34;
        vec = np.array(vector, dtype=float)
        if vec.shape != (3,):
            raise ValueError(f&#34;Shape of vector must be (3,), got {vec.shape}&#34;)
        
        if self.type == EOrientationSystems.CYLINDRICAL:
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
            
            phi = ref_pnt[1]
            c = self.copy()
            c.rotate_z(phi)
            return c._matrix.T @ vec 

        vec = self._matrix.T @ vec
        return vec

    def transform_vector_to_other(self, other:&#39;CoordinateSystem&#39;, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local vector into an other system and returns it.

        Args:
            other (CoordinateSystem): 
                The system to which the vector should be transformed.
            vector (npt.ArrayLike): 
                Local vector [x&#39;,y&#39;,z&#39;] to transform
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the vector is acting.
                Only required if this system OR the other is CYLINCRICAL.

        Returns:
            np.ndarray: Local vector [vx&#39;&#39;,vy&#39;&#39;,vz&#39;&#39;] in other system.
        &#34;&#34;&#34;

        if (self.type == EOrientationSystems.CYLINDRICAL or 
            other.type == EOrientationSystems.CYLINDRICAL):
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if this or other system is CYLINDRICAL&#34;)
            
            return other.transform_vector_from_global(
                        self.transform_vector_to_global(vector, ref_point),
                        self.transform_point_to_global(ref_point)
                    )
        # self and other are rectangular
        return other.transform_vector_from_global(
                    self.transform_vector_to_global(vector)
                )

    def transform_tensor_from_global(self, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given global tensor into this system and returns it.

        If this system is cartesian, the tensor is rotated into it and returned. 
        No ref_point is needed.

        The tensor can be either given as a vector with six components
        [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
        or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

        If this system is cylindrical, the returned components are:
        txx&#39;: Radial component in this system at the location of ref_point.
        tyy&#39;: tangential component in this system at the location of ref_point.
        tzz&#39;: axial component in this system.
        txy&#39;, tyz&#39;, txz&#39;: corresponding deviatorivc components

        Args:
            tensor (npt.ArrayLike): 
                Global cartesian tensor to transform. Of shape (6,) or (3,3)
            ref_point (npt.ArrayLike|None): 
                Reference point in global system, at which the tensor is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Local transformed tensor, same shape as given tensor.
        &#34;&#34;&#34;
        t, out_shape = self._2matrix(tensor)
        
        if self.type == EOrientationSystems.CYLINDRICAL:
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point, dtype=float)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
           
            phi = self.transform_point_from_global(ref_pnt)[1]
            c = self.copy()
            c.rotate_z(phi)
            t = c._matrix @ t @ c._matrix.T
            return self._2outshape(t, out_shape)

        t = self._matrix @ t @ self._matrix.T
        return self._2outshape(t, out_shape)

    def transform_tensor_to_global(self, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local tensor from this system into the global and returns it.

        If this system is cartesian, the tensor is rotated into global and returned. 
        No ref_point is needed.

        The tensor can be either given as a vector with six components
        [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
        or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

        If this system is cylindrical, the reference point at which the tensor is acting, 
        is required.

        Args:
            tensor (npt.ArrayLike): 
                Local tensor to transform. Of shape (6,) or (3,3)
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the tensor is acting.
                Only required if this system is CYLINCRICAL.

        Returns:
            np.ndarray: Global tensor, same shape as given tensor.
        &#34;&#34;&#34;
        t, out_shape = self._2matrix(tensor)

        if self.type == EOrientationSystems.CYLINDRICAL:
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
            ref_pnt = np.array(ref_point, dtype=float)
            if ref_pnt.shape != (3,):
                raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
            
            phi = ref_pnt[1]
            c = self.copy()
            c.rotate_z(phi)
            t = c._matrix.T @ t @ c._matrix
            return self._2outshape(t, out_shape)
        
        t = self._matrix.T @ t @ self._matrix
        return self._2outshape(t, out_shape)

    def transform_tensor_to_other(self, other:&#39;CoordinateSystem&#39;, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Transforms the given local tensor into an other system and returns it.

        The tensor can be either given as a vector with six components
        [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
        or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

        Args:
            other (CoordinateSystem): 
                The system to which the vector should be transformed.
            tensor (npt.ArrayLike): 
                Local tensor to transform. Of shape (6,) or (3,3)
            ref_point (npt.ArrayLike|None): 
                Reference point in this system at which the tensor is acting.
                Only required if this system OR the other is CYLINCRICAL.

        Returns:
            np.ndarray: Local vector in other system. Same shape as given tensor
        &#34;&#34;&#34;
        if (self.type == EOrientationSystems.CYLINDRICAL or 
            other.type == EOrientationSystems.CYLINDRICAL):
            if ref_point is None:
                raise ValueError(&#34;ref_point must be provided if this or other system is CYLINDRICAL&#34;)
            
            return other.transform_tensor_from_global(
                        self.transform_tensor_to_global(tensor, ref_point),
                        self.transform_point_to_global(ref_point)
                    )
        # self and other are rectangular
        return other.transform_tensor_from_global(
                    self.transform_tensor_to_global(tensor)
                )


    def _rotate(self, axis:int, ang:number, degrees:bool):

        rot_axis = self._matrix[axis]
        rot_ang = np.deg2rad(ang) if degrees else ang
        r = Rotation.from_rotvec(rot_axis * rot_ang)
        self._matrix = r.apply(self._matrix)

    def _2matrix(self, tensor:npt.ArrayLike) -&gt; tuple[np.ndarray, tuple[int,...]]:

        t = np.array(tensor, dtype=float)
        if t.shape == (6,):
            xx, yy, zz, xy, yz, zx = t
            return np.array([[xx, xy, zx],
                             [xy, yy, yz],
                             [zx, yz, zz]]), t.shape
        
        if t.shape == (3,3):
            return t, t.shape
        
        raise ValueError(f&#34;Shape of tensor must be (6,) or (3,3), got {t.shape}&#34;)

    def _2outshape(self, matrix:np.ndarray, out_shape:tuple[int,...]) -&gt; np.ndarray:
        if out_shape == (3,3):
            return matrix
        if out_shape == (6,):
            m = matrix
            return np.array([m[0,0], m[1,1], m[2,2], m[0,1], m[1,2], m[0,2]])
        
        raise ValueError(f&#34;out_shape must be (6,) or (3,3), got {out_shape}&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.matrix"><code class="name">var <span class="ident">matrix</span> : dataclasses.InitVar[typing.Union[typing.Sequence[typing.Sequence[int | float | numpy.number]], numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.origin"><code class="name">var <span class="ident">origin</span> : dataclasses.InitVar[typing.Union[typing.Sequence[int | float | numpy.number], numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.type"><code class="name">var <span class="ident">type</span> : <a title="pygccx.enums.EOrientationSystems" href="../enums.html#pygccx.enums.EOrientationSystems">EOrientationSystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an independant copy of this coordinate system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#39;CoordinateSystem&#39;: 
    &#34;&#34;&#34;Returns an independant copy of this coordinate system&#34;&#34;&#34;    
    return replace(self, origin=self._origin, matrix=self._matrix)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>self) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the orientation matrix of this coordinate system as 2D numpy array.
row 0: vector of x axis in global system
row 1: vector of y axis in global system
row 2: vector of z axis in global system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrix(self) -&gt; npt.NDArray:
    &#34;&#34;&#34;Gets the orientation matrix of this coordinate system as 2D numpy array.
    row 0: vector of x axis in global system
    row 1: vector of y axis in global system
    row 2: vector of z axis in global system
    &#34;&#34;&#34;
    return self._matrix</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.get_origin"><code class="name flex">
<span>def <span class="ident">get_origin</span></span>(<span>self) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the origin of this coordinate system as 1D numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_origin(self) -&gt; npt.NDArray:
    &#34;&#34;&#34;Gets the origin of this coordinate system as 1D numpy array&#34;&#34;&#34;
    return self._origin</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, v_inc: Union[Sequence[int | float | numpy.number], numpy.ndarray[Any, numpy.dtype[+ScalarType]]])</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the origin by the incrementation vector v_inc.</p>
<h2 id="args">Args</h2>
<p>v_inc (Sequence[number]|npt.NDArray): Incrementation vector in the form [dx, dy, dz]</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if length of v_inc is not 3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, v_inc:Sequence[number]|npt.NDArray):
    &#34;&#34;&#34;
    Moves the origin by the incrementation vector v_inc.

    Args:
        v_inc (Sequence[number]|npt.NDArray): Incrementation vector in the form [dx, dy, dz]

    Raises:
        ValueError: Raised if length of v_inc is not 3
    &#34;&#34;&#34;
    if len(v_inc) != 3:
        raise ValueError(f&#39;v_inc must have a length of 3, got {len(v_inc)}&#39;)
    self._origin += np.array(v_inc, dtype=float)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_x"><code class="name flex">
<span>def <span class="ident">rotate_x</span></span>(<span>self, ang: int | float | numpy.number, degrees: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates this coordinate system about its x-axis by the given angle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ang</code></strong> :&ensp;<code>number</code></dt>
<dd>Rotation angle </dd>
<dt><strong><code>degrees</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if ang is given in deg. Default = False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_x(self, ang:number, degrees:bool=False):
    &#34;&#34;&#34;
    Rotates this coordinate system about its x-axis by the given angle.

    Args:
        ang (number): Rotation angle 
        degrees (bool): Flag if ang is given in deg. Default = False
    &#34;&#34;&#34;
    self._rotate(0, ang, degrees)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_y"><code class="name flex">
<span>def <span class="ident">rotate_y</span></span>(<span>self, ang: int | float | numpy.number, degrees: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates this coordinate system about its y-axis by the given angle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ang</code></strong> :&ensp;<code>number</code></dt>
<dd>Rotation angle </dd>
<dt><strong><code>degrees</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if ang is given in deg. Default = False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_y(self, ang:number, degrees:bool=False):
    &#34;&#34;&#34;
    Rotates this coordinate system about its y-axis by the given angle.

    Args:
        ang (number): Rotation angle 
        degrees (bool): Flag if ang is given in deg. Default = False
    &#34;&#34;&#34;
    self._rotate(1, ang, degrees)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_z"><code class="name flex">
<span>def <span class="ident">rotate_z</span></span>(<span>self, ang: int | float | numpy.number, degrees: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates this coordinate system about its z-axis by the given angle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ang</code></strong> :&ensp;<code>number</code></dt>
<dd>Rotation angle </dd>
<dt><strong><code>degrees</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if ang is given in deg. Default = False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_z(self, ang:number, degrees:bool=False):
    &#34;&#34;&#34;
    Rotates this coordinate system about its z-axis by the given angle.

    Args:
        ang (number): Rotation angle 
        degrees (bool): Flag if ang is given in deg. Default = False
    &#34;&#34;&#34;
    self._rotate(2, ang, degrees)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.set_matrix"><code class="name flex">
<span>def <span class="ident">set_matrix</span></span>(<span>self, matrix: Union[Sequence[Sequence[int | float | numpy.number]], numpy.ndarray[Any, numpy.dtype[+ScalarType]]])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the orientation matrix of this coordinate system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>Sequence[Sequence[number]]</code></dt>
<dd>New matrix. Must be in the form
[[nxx,nxy,nxz],[nyx,nyy,nyz],[nzx,nzy,nzz]]
row 0: vector of x axis in global system
row 1: vector of y axis in global system
row 2: vector of z axis in global system</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if number of rows id not 3</dd>
<dt><code>ValueError</code></dt>
<dd>Raised if length of each row is not 3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_matrix(self, matrix:Sequence[Sequence[number]]|npt.NDArray):
    &#34;&#34;&#34;
    Sets the orientation matrix of this coordinate system.

    Args:
        matrix (Sequence[Sequence[number]]): New matrix. Must be in the form 
                                             [[nxx,nxy,nxz],[nyx,nyy,nyz],[nzx,nzy,nzz]]
                                             row 0: vector of x axis in global system
                                             row 1: vector of y axis in global system
                                             row 2: vector of z axis in global system

    Raises:
        ValueError: Raised if number of rows id not 3
        ValueError: Raised if length of each row is not 3
    &#34;&#34;&#34;
    if len(matrix) != 3:
        raise ValueError(f&#39;matrix must have a length of 3, got {len(matrix)}&#39;)
    if not all(len(r) == 3 for r in matrix):
        raise ValueError(f&#39;Each row in matrix must have a length of 3&#39;)
    self._matrix = np.array(matrix, dtype=float)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.set_origin"><code class="name flex">
<span>def <span class="ident">set_origin</span></span>(<span>self, origin: Union[Sequence[int | float | numpy.number], numpy.ndarray[Any, numpy.dtype[+ScalarType]]])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the origin of this coordinate system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>origin</code></strong> :&ensp;<code>Sequence[number]</code></dt>
<dd>New origin. Must be in the form [x,y,z]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if length of origin is not 3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_origin(self, origin:Sequence[number]|npt.NDArray):
    &#34;&#34;&#34;
    Sets the origin of this coordinate system.

    Args:
        origin (Sequence[number]): New origin. Must be in the form [x,y,z]

    Raises:
        ValueError: Raised if length of origin is not 3
    &#34;&#34;&#34;
    if len(origin) != 3:
        raise ValueError(f&#39;origin must have a length of 3, got {len(origin)}&#39;)
    self._origin = np.array(origin, dtype=float)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_from_global"><code class="name flex">
<span>def <span class="ident">transform_point_from_global</span></span>(<span>self, point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given global cartesian point coordinates into this system and
returns the new coordinates.</p>
<p>If this system is cartesian, cartesian coordinates
[x', y', z'] are returned.
If this system is cylindrical, polar coordinates
[r', theta'(rad), z'] are returned</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Global cartesian coordinates [x1,y1,z1]
of point to transform
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Local coordinates [x',y',z'] or [r', theta', z'].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_point_from_global(self, point:npt.ArrayLike) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given global cartesian point coordinates into this system and
    returns the new coordinates.

    If this system is cartesian, cartesian coordinates 
    [x&#39;, y&#39;, z&#39;] are returned.
    If this system is cylindrical, polar coordinates 
    [r&#39;, theta&#39;(rad), z&#39;] are returned

    Args:
        points (npt.ArrayLike): 
            Global cartesian coordinates [x1,y1,z1]
            of point to transform  

    Returns:
        np.ndarray: Local coordinates [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;, z&#39;].
    &#34;&#34;&#34;

    pnt = np.array(point, dtype=float)
    if pnt.shape != (3,):
        raise ValueError(f&#34;Shape of point must be (3,), got {pnt.shape}&#34;)
    
    pnt -= self._origin
    pnt = self._matrix @ pnt

    if self.type == EOrientationSystems.CYLINDRICAL: 
        pnt[0], pnt[1] = (np.hypot(pnt[0], pnt[1]),
                                np.arctan2(pnt[1], pnt[0]))

    return pnt</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_to_global"><code class="name flex">
<span>def <span class="ident">transform_point_to_global</span></span>(<span>self, point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given local point coordinates into the global system and
returns the new coordinates.</p>
<p>If this system is cartesian, points must contain local cartesian coordinates
[x', y', z'].
If this system is cylindrical, points must contain local cylindrical coordinates
[r', theta'(rad), z'].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>local cartesian or cylindriacl coordinates
[x',y',z'] or [r', theta'(rad), z']
of points to transform
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>global cartesian coordinates [x, y, z].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_point_to_global(self, point:npt.ArrayLike) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given local point coordinates into the global system and
    returns the new coordinates.

    If this system is cartesian, points must contain local cartesian coordinates 
    [x&#39;, y&#39;, z&#39;].
    If this system is cylindrical, points must contain local cylindrical coordinates
    [r&#39;, theta&#39;(rad), z&#39;].

    Args:
        points (npt.ArrayLike): 
            local cartesian or cylindriacl coordinates 
            [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;(rad), z&#39;]
            of points to transform  

    Returns:
        np.ndarray: global cartesian coordinates [x, y, z].
    &#34;&#34;&#34;

    pnt = np.array(point, dtype=float)
    if pnt.shape != (3,):
        raise ValueError(f&#34;Shape of point must be (3,), got {pnt.shape}&#34;)
    
    if self.type == EOrientationSystems.CYLINDRICAL:
        pnt[0], pnt[1] = (np.cos(pnt[1]) * pnt[0],
                                np.sin(pnt[1]) * pnt[0])
        
    pnts = self._matrix.T @ pnt
    pnts += self._origin

    return pnts</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_to_other"><code class="name flex">
<span>def <span class="ident">transform_point_to_other</span></span>(<span>self, point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], other: <a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given point coordinates from this system into an other
system and returns the new coordinates.</p>
<p>If this system is cartesian, points must contain local cartesian coordinates
[x', y', z'].
If this system is cylindrical, points must contain local cylindrical coordinates
[r', theta'(rad), z'].</p>
<p>If other system is cartesian, cartesian coordinates
[x'', y'', z''] are returned.
If other system is cylindrical, polar coordinates
[[r'', theta''(rad), z''], &hellip;] are returned</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Local coordinates [x',y',z'] or [r', theta', z'] of points to transform</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Local coordinates [x'',y'',z''] or [r'', theta'', z''].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_point_to_other(self, point:npt.ArrayLike, other:&#39;CoordinateSystem&#39;) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given point coordinates from this system into an other
    system and returns the new coordinates.

    If this system is cartesian, points must contain local cartesian coordinates 
    [x&#39;, y&#39;, z&#39;].
    If this system is cylindrical, points must contain local cylindrical coordinates
    [r&#39;, theta&#39;(rad), z&#39;].

    If other system is cartesian, cartesian coordinates 
    [x&#39;&#39;, y&#39;&#39;, z&#39;&#39;] are returned.
    If other system is cylindrical, polar coordinates 
    [[r&#39;&#39;, theta&#39;&#39;(rad), z&#39;&#39;], ...] are returned

    Args:
        point (npt.ArrayLike): 
            Local coordinates [x&#39;,y&#39;,z&#39;] or [r&#39;, theta&#39;, z&#39;] of points to transform

    Returns:
        np.ndarray: Local coordinates [x&#39;&#39;,y&#39;&#39;,z&#39;&#39;] or [r&#39;&#39;, theta&#39;&#39;, z&#39;&#39;].
    &#34;&#34;&#34;
    return other.transform_point_from_global(
               self.transform_point_to_global(point)
               )</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_from_global"><code class="name flex">
<span>def <span class="ident">transform_tensor_from_global</span></span>(<span>self, tensor: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], ref_point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]], ForwardRef(None)] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given global tensor into this system and returns it.</p>
<p>If this system is cartesian, the tensor is rotated into it and returned.
No ref_point is needed.</p>
<p>The tensor can be either given as a vector with six components
[txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].</p>
<p>If this system is cylindrical, the returned components are:
txx': Radial component in this system at the location of ref_point.
tyy': tangential component in this system at the location of ref_point.
tzz': axial component in this system.
txy', tyz', txz': corresponding deviatorivc components</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Global cartesian tensor to transform. Of shape (6,) or (3,3)</dd>
</dl>
<p>ref_point (npt.ArrayLike|None):
Reference point in global system, at which the tensor is acting.
Only required if this system is CYLINCRICAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Local transformed tensor, same shape as given tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_tensor_from_global(self, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given global tensor into this system and returns it.

    If this system is cartesian, the tensor is rotated into it and returned. 
    No ref_point is needed.

    The tensor can be either given as a vector with six components
    [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
    or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

    If this system is cylindrical, the returned components are:
    txx&#39;: Radial component in this system at the location of ref_point.
    tyy&#39;: tangential component in this system at the location of ref_point.
    tzz&#39;: axial component in this system.
    txy&#39;, tyz&#39;, txz&#39;: corresponding deviatorivc components

    Args:
        tensor (npt.ArrayLike): 
            Global cartesian tensor to transform. Of shape (6,) or (3,3)
        ref_point (npt.ArrayLike|None): 
            Reference point in global system, at which the tensor is acting.
            Only required if this system is CYLINCRICAL.

    Returns:
        np.ndarray: Local transformed tensor, same shape as given tensor.
    &#34;&#34;&#34;
    t, out_shape = self._2matrix(tensor)
    
    if self.type == EOrientationSystems.CYLINDRICAL:
        if ref_point is None:
            raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
        ref_pnt = np.array(ref_point, dtype=float)
        if ref_pnt.shape != (3,):
            raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
       
        phi = self.transform_point_from_global(ref_pnt)[1]
        c = self.copy()
        c.rotate_z(phi)
        t = c._matrix @ t @ c._matrix.T
        return self._2outshape(t, out_shape)

    t = self._matrix @ t @ self._matrix.T
    return self._2outshape(t, out_shape)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_to_global"><code class="name flex">
<span>def <span class="ident">transform_tensor_to_global</span></span>(<span>self, tensor: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], ref_point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]], ForwardRef(None)] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given local tensor from this system into the global and returns it.</p>
<p>If this system is cartesian, the tensor is rotated into global and returned.
No ref_point is needed.</p>
<p>The tensor can be either given as a vector with six components
[txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].</p>
<p>If this system is cylindrical, the reference point at which the tensor is acting,
is required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Local tensor to transform. Of shape (6,) or (3,3)</dd>
</dl>
<p>ref_point (npt.ArrayLike|None):
Reference point in this system at which the tensor is acting.
Only required if this system is CYLINCRICAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Global tensor, same shape as given tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_tensor_to_global(self, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given local tensor from this system into the global and returns it.

    If this system is cartesian, the tensor is rotated into global and returned. 
    No ref_point is needed.

    The tensor can be either given as a vector with six components
    [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
    or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

    If this system is cylindrical, the reference point at which the tensor is acting, 
    is required.

    Args:
        tensor (npt.ArrayLike): 
            Local tensor to transform. Of shape (6,) or (3,3)
        ref_point (npt.ArrayLike|None): 
            Reference point in this system at which the tensor is acting.
            Only required if this system is CYLINCRICAL.

    Returns:
        np.ndarray: Global tensor, same shape as given tensor.
    &#34;&#34;&#34;
    t, out_shape = self._2matrix(tensor)

    if self.type == EOrientationSystems.CYLINDRICAL:
        if ref_point is None:
            raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
        ref_pnt = np.array(ref_point, dtype=float)
        if ref_pnt.shape != (3,):
            raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
        
        phi = ref_pnt[1]
        c = self.copy()
        c.rotate_z(phi)
        t = c._matrix.T @ t @ c._matrix
        return self._2outshape(t, out_shape)
    
    t = self._matrix.T @ t @ self._matrix
    return self._2outshape(t, out_shape)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_to_other"><code class="name flex">
<span>def <span class="ident">transform_tensor_to_other</span></span>(<span>self, other: <a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a>, tensor: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], ref_point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]], ForwardRef(None)] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given local tensor into an other system and returns it.</p>
<p>The tensor can be either given as a vector with six components
[txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The system to which the vector should be transformed.</dd>
<dt><strong><code>tensor</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Local tensor to transform. Of shape (6,) or (3,3)</dd>
</dl>
<p>ref_point (npt.ArrayLike|None):
Reference point in this system at which the tensor is acting.
Only required if this system OR the other is CYLINCRICAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Local vector in other system. Same shape as given tensor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_tensor_to_other(self, other:&#39;CoordinateSystem&#39;, tensor:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given local tensor into an other system and returns it.

    The tensor can be either given as a vector with six components
    [txx, tyy, tzz, txy, tyz, tzx] (this assumes a symmetric tensor, like stress),
    or as a 3x3 matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]].

    Args:
        other (CoordinateSystem): 
            The system to which the vector should be transformed.
        tensor (npt.ArrayLike): 
            Local tensor to transform. Of shape (6,) or (3,3)
        ref_point (npt.ArrayLike|None): 
            Reference point in this system at which the tensor is acting.
            Only required if this system OR the other is CYLINCRICAL.

    Returns:
        np.ndarray: Local vector in other system. Same shape as given tensor
    &#34;&#34;&#34;
    if (self.type == EOrientationSystems.CYLINDRICAL or 
        other.type == EOrientationSystems.CYLINDRICAL):
        if ref_point is None:
            raise ValueError(&#34;ref_point must be provided if this or other system is CYLINDRICAL&#34;)
        
        return other.transform_tensor_from_global(
                    self.transform_tensor_to_global(tensor, ref_point),
                    self.transform_point_to_global(ref_point)
                )
    # self and other are rectangular
    return other.transform_tensor_from_global(
                self.transform_tensor_to_global(tensor)
            )</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_from_global"><code class="name flex">
<span>def <span class="ident">transform_vector_from_global</span></span>(<span>self, vector: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], ref_point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]], ForwardRef(None)] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given global vector into this system and returns it.</p>
<p>If this system is cartesian, the vector is rotated into it and returned.
No ref_point is needed.</p>
<p>If this system is cylindrical, the returned components are:
vx': Radial component in this system at the location of ref_point.
vy': tangential component in this system at the location of ref_point.
vz': axial component in this system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Global cartesian vector [vx, vy, vz] to transform.</dd>
</dl>
<p>ref_point (npt.ArrayLike|None):
Reference point in global system, at which the vector is acting.
Only required if this system is CYLINCRICAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Local vector [vx', vy', vz'].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_vector_from_global(self, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given global vector into this system and returns it.

    If this system is cartesian, the vector is rotated into it and returned. 
    No ref_point is needed.

    If this system is cylindrical, the returned components are:
    vx&#39;: Radial component in this system at the location of ref_point.
    vy&#39;: tangential component in this system at the location of ref_point.
    vz&#39;: axial component in this system.

    Args:
        vector (npt.ArrayLike): 
            Global cartesian vector [vx, vy, vz] to transform.
        ref_point (npt.ArrayLike|None): 
            Reference point in global system, at which the vector is acting.
            Only required if this system is CYLINCRICAL.

    Returns:
        np.ndarray: Local vector [vx&#39;, vy&#39;, vz&#39;].
    &#34;&#34;&#34;

    vec = np.array(vector, dtype=float)
    if vec.shape != (3,):
        raise ValueError(f&#34;Shape of vector must be (3,), got {vec.shape}&#34;)

    if self.type == EOrientationSystems.CYLINDRICAL: 
        if ref_point is None:
            raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
        ref_pnt = np.array(ref_point, dtype=float)
        if ref_pnt.shape != (3,):
            raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
       
        phi = self.transform_point_from_global(ref_pnt)[1]
        c = self.copy()
        c.rotate_z(phi)
        return c._matrix @ vec 

    vec = self._matrix @ vec
    return vec</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_to_global"><code class="name flex">
<span>def <span class="ident">transform_vector_to_global</span></span>(<span>self, vector: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], ref_point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]], ForwardRef(None)] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given local vector from this system into the global and returns it.</p>
<p>If this system is cartesian, the vector is rotated into global and returned.
No ref_point is needed.</p>
<p>If this system is cylindrical, the reference point at which the vector is acting,
is required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Local vector [vx', vy', vz'] to transform.</dd>
</dl>
<p>ref_point (npt.ArrayLike|None):
Reference point in this system at which the vector is acting.
Only required if this system is CYLINCRICAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Global vector [vx, vy, vz].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_vector_to_global(self, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given local vector from this system into the global and returns it.

    If this system is cartesian, the vector is rotated into global and returned. 
    No ref_point is needed.

    If this system is cylindrical, the reference point at which the vector is acting, 
    is required.

    Args:
        vector (npt.ArrayLike): 
            Local vector [vx&#39;, vy&#39;, vz&#39;] to transform.
        ref_point (npt.ArrayLike|None): 
            Reference point in this system at which the vector is acting.
            Only required if this system is CYLINCRICAL.

    Returns:
        np.ndarray: Global vector [vx, vy, vz].
    &#34;&#34;&#34;
    vec = np.array(vector, dtype=float)
    if vec.shape != (3,):
        raise ValueError(f&#34;Shape of vector must be (3,), got {vec.shape}&#34;)
    
    if self.type == EOrientationSystems.CYLINDRICAL:
        if ref_point is None:
            raise ValueError(&#34;ref_point must be provided if coordinate system is CYLINDRICAL&#34;)
        ref_pnt = np.array(ref_point)
        if ref_pnt.shape != (3,):
            raise ValueError(f&#34;Shape of ref_point must be (3,), got {ref_pnt.shape}&#34;)
        
        phi = ref_pnt[1]
        c = self.copy()
        c.rotate_z(phi)
        return c._matrix.T @ vec 

    vec = self._matrix.T @ vec
    return vec</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_to_other"><code class="name flex">
<span>def <span class="ident">transform_vector_to_other</span></span>(<span>self, other: <a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a>, vector: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], ref_point: Union[numpy._array_like._SupportsArray[numpy.dtype], numpy._nested_sequence._NestedSequence[numpy._array_like._SupportsArray[numpy.dtype]], bool, int, float, complex, str, bytes, numpy._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]], ForwardRef(None)] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given local vector into an other system and returns it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>The system to which the vector should be transformed.</dd>
<dt><strong><code>vector</code></strong> :&ensp;<code>npt.ArrayLike</code></dt>
<dd>Local vector [x',y',z'] to transform</dd>
</dl>
<p>ref_point (npt.ArrayLike|None):
Reference point in this system at which the vector is acting.
Only required if this system OR the other is CYLINCRICAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Local vector [vx'',vy'',vz''] in other system.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_vector_to_other(self, other:&#39;CoordinateSystem&#39;, vector:npt.ArrayLike, ref_point:npt.ArrayLike|None=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transforms the given local vector into an other system and returns it.

    Args:
        other (CoordinateSystem): 
            The system to which the vector should be transformed.
        vector (npt.ArrayLike): 
            Local vector [x&#39;,y&#39;,z&#39;] to transform
        ref_point (npt.ArrayLike|None): 
            Reference point in this system at which the vector is acting.
            Only required if this system OR the other is CYLINCRICAL.

    Returns:
        np.ndarray: Local vector [vx&#39;&#39;,vy&#39;&#39;,vz&#39;&#39;] in other system.
    &#34;&#34;&#34;

    if (self.type == EOrientationSystems.CYLINDRICAL or 
        other.type == EOrientationSystems.CYLINDRICAL):
        if ref_point is None:
            raise ValueError(&#34;ref_point must be provided if this or other system is CYLINDRICAL&#34;)
        
        return other.transform_vector_from_global(
                    self.transform_vector_to_global(vector, ref_point),
                    self.transform_point_to_global(ref_point)
                )
    # self and other are rectangular
    return other.transform_vector_from_global(
                self.transform_vector_to_global(vector)
            )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygccx.helper_features" href="index.html">pygccx.helper_features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem" href="#pygccx.helper_features.coordinate_system.CoordinateSystem">CoordinateSystem</a></code></h4>
<ul class="">
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.copy" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.copy">copy</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.get_matrix" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.get_matrix">get_matrix</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.get_origin" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.get_origin">get_origin</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.matrix" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.matrix">matrix</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.move" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.move">move</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.name" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.name">name</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.origin" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.origin">origin</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_x" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_x">rotate_x</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_y" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_y">rotate_y</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_z" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.rotate_z">rotate_z</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.set_matrix" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.set_matrix">set_matrix</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.set_origin" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.set_origin">set_origin</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_from_global" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_from_global">transform_point_from_global</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_to_global" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_to_global">transform_point_to_global</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_to_other" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_point_to_other">transform_point_to_other</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_from_global" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_from_global">transform_tensor_from_global</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_to_global" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_to_global">transform_tensor_to_global</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_to_other" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_tensor_to_other">transform_tensor_to_other</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_from_global" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_from_global">transform_vector_from_global</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_to_global" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_to_global">transform_vector_to_global</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_to_other" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.transform_vector_to_other">transform_vector_to_other</a></code></li>
<li><code><a title="pygccx.helper_features.coordinate_system.CoordinateSystem.type" href="#pygccx.helper_features.coordinate_system.CoordinateSystem.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>