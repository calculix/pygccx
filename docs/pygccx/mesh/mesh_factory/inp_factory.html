<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygccx.mesh.mesh_factory.inp_factory API documentation</title>
<meta name="description" content="Copyright Matthias Sedlmaier 2022
This file is part of pygccx …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygccx.mesh.mesh_factory.inp_factory</code></h1>
</header>
<section id="section-intro">
<p>Copyright Matthias Sedlmaier 2022
This file is part of pygccx.</p>
<p>pygccx is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.</p>
<p>pygccx is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with pygccx.<br>
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Copyright Matthias Sedlmaier 2022
This file is part of pygccx.

pygccx is free software: you can redistribute it 
and/or modify it under the terms of the GNU General Public License as 
published by the Free Software Foundation, either version 3 of the 
License, or (at your option) any later version.

pygccx is distributed in the hope that it will 
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pygccx.  
If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#39;&#39;&#39;

import csv
from typing import Iterator
from .. import Mesh, Element, Set
from ..element import NODE_COUNT_TABLE
from ..surface import NodeSurface, ElementSurface
from pygccx.enums import EEtypes, ESetTypes, ESurfTypes
from pygccx.protocols import ISet, ISurface
from pygccx.exceptions import ElementTypeNotSupportedError


def mesh_from_inp(filename:str, ignore_unsup_elems:bool=False, clear_mesh:bool=False) -&gt; Mesh:
    &#34;&#34;&#34;
    Builds a pygccx mesh object from the given ccx input file.

    Only nodes, 3D solid elements, node- and element sets and surfaces will be read.

    If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
    If False, an ElementTypeNotSupportedError is raised if there are unsupported
    elements in the file.

    if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
    node ids and element faces which are not referred by any element are removed from every
    set and surface. If False, no clearing is done. 

    Args:
        filename (str): File name incl. path of ccx input file. 
        ignore_unsup_elems (bool, optional): Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError
            is raised if an unsupported solid element is processed. Defaults to False.
        clear_mesh (bool, optional): Flag if mesh object should be cleared. 
    
    Returns:
        Mesh: The converted mesh
    &#34;&#34;&#34;
    mesh = _parse_content(filename, ignore_unsup_elems, 
                read_nodes=True, read_elems=True,
                read_nsets=True, read_elsets=True,
                read_surfs=True,)
    if clear_mesh: return _clear_mesh(mesh)
    return mesh

def nsets_from_inp(filename:str) -&gt; list[ISet]:

    mesh = _parse_content(filename, True, read_nsets=True)
    return mesh.node_sets

def elsets_from_inp(filename:str) -&gt; list[ISet]:

    mesh = _parse_content(filename, True, read_elsets=True)
    return mesh.element_sets

def surfaces_from_inp(filename:str) -&gt; list[ISurface]:

    mesh = _parse_content(filename, True, read_surfs=True)
    return mesh.surfaces

def _read_and_expand_inp(filename:str) -&gt; list[list[str]]:

    out = []
    with open(filename) as f:
        csv_reader = csv.reader(f, delimiter=&#39;,&#39;)

        for line in csv_reader:
            if not line : continue
            line = line if line[-1] else line[:-1] # delete empty last element
            if line[0] == &#39;*INCLUDE&#39;:
                input = line[1].split(&#39;=&#39;)[-1]
                out += _read_and_expand_inp(input)
            else:
                out.append(line)
    return out

def _parse_content(filename:str, ignore:bool=False, **options):

    read_nodes = options.get(&#39;read_nodes&#39;, False)
    read_elems = options.get(&#39;read_elems&#39;, False)
    read_nsets = options.get(&#39;read_nsets&#39;, False)
    read_elsets = options.get(&#39;read_elsets&#39;, False)
    read_surfs = options.get(&#39;read_surfs&#39;, False)

    lines = iter(_read_and_expand_inp(filename))
    nodes = {}
    elems = {}
    nsets:dict[str, ISet] = {}
    elsets:dict[str, ISet] = {}
    surfs:list[ISurface] = []

    line = next(lines, None)
    while line:

        key = line[0].upper()

        if key.startswith(&#39;*&#39;):
            if key == &#39;*NODE&#39; and read_nodes:
                n, s, line = _read_node_block(line, lines)
                nodes.update(n)
                if s and read_nsets:
                    if s.name not in nsets: nsets[s.name] = s
                    else: nsets[s.name].ids.update(s.ids)             
                continue
            elif key == &#39;*ELEMENT&#39; and read_elems:
                e, s, line = _read_element_block(line, lines, ignore)
                elems.update(e)
                if s and read_elsets:
                    if s.name not in elsets: elsets[s.name] = s
                    else: elsets[s.name].ids.update(s.ids)  
                continue
            elif key == &#39;*NSET&#39; and read_nsets:
                s, line = _read_nset_block(line, lines)
                if s: 
                    if s.name not in nsets: nsets[s.name] = s
                    else: nsets[s.name].ids.update(s.ids)  
                continue
            elif key == &#39;*ELSET&#39; and read_elsets:
                s, line = _read_elset_block(line, lines)
                if s:
                    if s.name not in elsets: elsets[s.name] = s
                    else: elsets[s.name].ids.update(s.ids)  
                continue
            elif key == &#39;*SURFACE&#39; and read_surfs:
                surf, line = _read_surface_block(line, lines)
                if surf: surfs.append(surf)
                continue
                

        line = next(lines, None)
        
    return Mesh(nodes, elems, list(nsets.values()), 
                list(elsets.values()), surfs)

def _get_param_value(line:list[str], param_name:str) -&gt; str|None:

    val = None
    for c in line:
        if c.upper().startswith(param_name.upper()):
            return c.split(&#39;=&#39;)[-1]

def _read_node_block(line:list[str], lines:Iterator[list[str]]) -&gt; tuple[dict, ISet|None, list[str]]:

    set_name = _get_param_value(line, &#39;NSET&#39;)

    nodes = {}
    for line in lines:
        if line[0].startswith(&#39;*&#39;): break

        id = int(line[0])
        coords = tuple(float(c) for c in line[1:])
        nodes[id] = coords

    nset = None
    if set_name:
        nset = Set(set_name.upper(), ESetTypes.NODE, set(nodes.keys()))

    return nodes, nset, line

def _read_element_block(line:list[str], lines:Iterator[list[str]], ignore:bool) -&gt; tuple[dict, ISet|None, list[str]]:

    # check if node set is specified:
    set_name = _get_param_value(line, &#39;ELSET&#39;)

    # get element type
    etype = _get_param_value(line, &#39;TYPE&#39;)
    if not _check_etype(etype, ignore):
        return {}, None, next(lines, None)  # type: ignore

    etype = EEtypes[etype.upper()] # type: ignore
      
    elems = {}
    for line in lines:
        if line[0].startswith(&#39;*&#39;): break

        eid = int(line[0])
        nids = tuple(int(c) for c in line[1:])
        if NODE_COUNT_TABLE[etype] &gt; 15:
            nids += tuple(int(c) for c in next(lines))
        elems[eid] = Element(eid, etype, nids)

    elset = None
    if set_name:
        elset = Set(set_name.upper(), ESetTypes.ELEMENT, set(elems.keys()))

    return elems, elset, line

def _read_nset_block(line:list[str], lines:Iterator[list[str]]) -&gt; tuple[ISet, list[str]]:

    set_name = _get_param_value(line, &#39;NSET&#39;)   
    generate = &#39;GENERATE&#39; in &#39;,&#39;.join(line).upper()

    if generate:
        line = next(lines)
        start, stop, inc = [int(c) for c in line]
        nids = range(start, stop+1, inc)
        return Set(set_name.upper(), ESetTypes.NODE, 0, set(nids)), line  # type: ignore

    nids = []
    for line in lines:
        if line[0].startswith(&#39;*&#39;): break
        nids += [int(c) for c in line if c]
    return Set(set_name.upper(), ESetTypes.NODE, set(nids)), line  # type: ignore

def _read_elset_block(line:list[str], lines:Iterator[list[str]]) -&gt; tuple[ISet, list[str]]:
    set_name = _get_param_value(line, &#39;ELSET&#39;)   
    generate = &#39;GENERATE&#39; in &#39;,&#39;.join(line).upper()

    if generate:
        line = next(lines)
        start, stop, inc = [int(c) for c in line]
        eids = range(start, stop+1, inc)
        return Set(set_name.upper(), ESetTypes.ELEMENT, 0, set(eids)), line  # type: ignore

    eids = []
    for line in lines:
        if line[0].startswith(&#39;*&#39;): break
        eids += [int(c) for c in line if c]
    return Set(set_name.upper(), ESetTypes.ELEMENT, set(eids)), line  # type: ignore

def _read_surface_block(line:list[str], lines:Iterator[list[str]]) -&gt; tuple[ISurface, list[str]]:

    surf_name = _get_param_value(line, &#39;NAME&#39;)   
    if surf_name: surf_name = surf_name.upper()
    surf_type = _get_param_value(line, &#39;TYPE&#39;)
    if surf_type: surf_type = ESurfTypes(surf_type)
    else: surf_type = ESurfTypes.EL_FACE

    if surf_type == ESurfTypes.EL_FACE:
        faces = set[tuple[int,...]]()
        for line in lines:
            if line[0].startswith(&#39;*&#39;): break
            faces.add((int(line[0]), int(line[1][1:])))
        
        return ElementSurface(surf_name, faces), line  # type: ignore

    nids = set[int]()
    set_names = set[str]()
    for line in lines:
        if line[0].startswith(&#39;*&#39;): break
        try:
            nids.add(int(line[0]))
        except:
            set_names.add(line[0])
    return NodeSurface(surf_name, nids, set_names), line  # type: ignore

def _check_etype(etype:str|None, ignore:bool) -&gt; bool:

    if not etype:
        if ignore: return False
        raise ElementTypeNotSupportedError(
            f&#39;Element with type {etype} is not supported!&#39;
        )

    if not etype.upper() in {e.name for e in EEtypes}:
        if ignore: return False
        raise ElementTypeNotSupportedError(
            f&#39;Element with type {etype} is not supported!&#39;
        )
    return True

def _clear_mesh(mesh:Mesh) -&gt; Mesh:

    used_nodes = set[int]()
    for e in mesh.elements.values():
        used_nodes.update(e.node_ids)

    # clear nodes
    mesh.nodes = {nid: mesh.nodes[nid] for nid in used_nodes}

    # clear nsets
    for nset in mesh.node_sets:
        nset.ids.intersection_update(used_nodes)

    # clear elsets
    for elset in mesh.element_sets:
        elset.ids.intersection_update(mesh.elements)

    # clear surfaces
    node_set_names = {s.name for s in mesh.node_sets}
    for s in mesh.surfaces:
        if isinstance(s, ElementSurface): 
            faces = {f for f in s.element_faces if f[0] in mesh.elements}
            s.element_faces.intersection_update(faces)
        elif isinstance(s, NodeSurface):
            s.node_ids.intersection_update(used_nodes)
            s.node_set_names.intersection_update(node_set_names)

    return mesh</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pygccx.mesh.mesh_factory.inp_factory.elsets_from_inp"><code class="name flex">
<span>def <span class="ident">elsets_from_inp</span></span>(<span>filename: str) ‑> list[<a title="pygccx.protocols.ISet" href="../../protocols.html#pygccx.protocols.ISet">ISet</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elsets_from_inp(filename:str) -&gt; list[ISet]:

    mesh = _parse_content(filename, True, read_elsets=True)
    return mesh.element_sets</code></pre>
</details>
</dd>
<dt id="pygccx.mesh.mesh_factory.inp_factory.mesh_from_inp"><code class="name flex">
<span>def <span class="ident">mesh_from_inp</span></span>(<span>filename: str, ignore_unsup_elems: bool = False, clear_mesh: bool = False) ‑> <a title="pygccx.mesh.mesh.Mesh" href="../mesh.html#pygccx.mesh.mesh.Mesh">Mesh</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds a pygccx mesh object from the given ccx input file.</p>
<p>Only nodes, 3D solid elements, node- and element sets and surfaces will be read.</p>
<p>If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
If False, an ElementTypeNotSupportedError is raised if there are unsupported
elements in the file.</p>
<p>if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
node ids and element faces which are not referred by any element are removed from every
set and surface. If False, no clearing is done. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>File name incl. path of ccx input file. </dd>
<dt><strong><code>ignore_unsup_elems</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError
is raised if an unsupported solid element is processed. Defaults to False.</dd>
<dt><strong><code>clear_mesh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag if mesh object should be cleared. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Mesh</code></dt>
<dd>The converted mesh</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh_from_inp(filename:str, ignore_unsup_elems:bool=False, clear_mesh:bool=False) -&gt; Mesh:
    &#34;&#34;&#34;
    Builds a pygccx mesh object from the given ccx input file.

    Only nodes, 3D solid elements, node- and element sets and surfaces will be read.

    If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
    If False, an ElementTypeNotSupportedError is raised if there are unsupported
    elements in the file.

    if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
    node ids and element faces which are not referred by any element are removed from every
    set and surface. If False, no clearing is done. 

    Args:
        filename (str): File name incl. path of ccx input file. 
        ignore_unsup_elems (bool, optional): Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError
            is raised if an unsupported solid element is processed. Defaults to False.
        clear_mesh (bool, optional): Flag if mesh object should be cleared. 
    
    Returns:
        Mesh: The converted mesh
    &#34;&#34;&#34;
    mesh = _parse_content(filename, ignore_unsup_elems, 
                read_nodes=True, read_elems=True,
                read_nsets=True, read_elsets=True,
                read_surfs=True,)
    if clear_mesh: return _clear_mesh(mesh)
    return mesh</code></pre>
</details>
</dd>
<dt id="pygccx.mesh.mesh_factory.inp_factory.nsets_from_inp"><code class="name flex">
<span>def <span class="ident">nsets_from_inp</span></span>(<span>filename: str) ‑> list[<a title="pygccx.protocols.ISet" href="../../protocols.html#pygccx.protocols.ISet">ISet</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nsets_from_inp(filename:str) -&gt; list[ISet]:

    mesh = _parse_content(filename, True, read_nsets=True)
    return mesh.node_sets</code></pre>
</details>
</dd>
<dt id="pygccx.mesh.mesh_factory.inp_factory.surfaces_from_inp"><code class="name flex">
<span>def <span class="ident">surfaces_from_inp</span></span>(<span>filename: str) ‑> list[<a title="pygccx.protocols.ISurface" href="../../protocols.html#pygccx.protocols.ISurface">ISurface</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surfaces_from_inp(filename:str) -&gt; list[ISurface]:

    mesh = _parse_content(filename, True, read_surfs=True)
    return mesh.surfaces</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygccx.mesh.mesh_factory" href="index.html">pygccx.mesh.mesh_factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pygccx.mesh.mesh_factory.inp_factory.elsets_from_inp" href="#pygccx.mesh.mesh_factory.inp_factory.elsets_from_inp">elsets_from_inp</a></code></li>
<li><code><a title="pygccx.mesh.mesh_factory.inp_factory.mesh_from_inp" href="#pygccx.mesh.mesh_factory.inp_factory.mesh_from_inp">mesh_from_inp</a></code></li>
<li><code><a title="pygccx.mesh.mesh_factory.inp_factory.nsets_from_inp" href="#pygccx.mesh.mesh_factory.inp_factory.nsets_from_inp">nsets_from_inp</a></code></li>
<li><code><a title="pygccx.mesh.mesh_factory.inp_factory.surfaces_from_inp" href="#pygccx.mesh.mesh_factory.inp_factory.surfaces_from_inp">surfaces_from_inp</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>