<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygccx.model API documentation</title>
<meta name="description" content="Copyright Matthias Sedlmaier 2022
This file is part of pygccx …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygccx.model</code></h1>
</header>
<section id="section-intro">
<p>Copyright Matthias Sedlmaier 2022
This file is part of pygccx.</p>
<p>pygccx is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.</p>
<p>pygccx is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with pygccx.<br>
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Copyright Matthias Sedlmaier 2022
This file is part of pygccx.

pygccx is free software: you can redistribute it 
and/or modify it under the terms of the GNU General Public License as 
published by the Free Software Foundation, either version 3 of the 
License, or (at your option) any later version.

pygccx is distributed in the hope that it will 
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pygccx.  
If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#39;&#39;&#39;

import os, pickle
import subprocess
from dataclasses import dataclass, field
from typing import Optional

import gmsh as _gmsh

_gmsh.initialize()
_gmsh.option.setNumber(&#34;Mesh.SecondOrderIncomplete&#34;, 1)

from . import mesh as msh
from . import enums
from .protocols import IKeyword, IStep
from .result_reader import FrdResult, DatResult

@dataclass
class Model:

    ccx_path:str
    &#34;&#34;&#34;Path to ccx executable&#34;&#34;&#34;
    cgx_path:str
    &#34;&#34;&#34;Path to cgx executable&#34;&#34;&#34;
    jobname:str = &#39;jobname&#39;
    &#34;&#34;&#34;Name of the job. All generated files will have this name.&#34;&#34;&#34;
    working_dir:str = field(default_factory=os.getcwd)
    &#34;&#34;&#34;Working directory where all generated files will be stored&#34;&#34;&#34;
    mesh:msh.Mesh = field(init=False)
    &#34;&#34;&#34;Mesh object of this model&#34;&#34;&#34;
    model_keywords:list[IKeyword] = field(default_factory=list, init=False)
    &#34;&#34;&#34;List of model keywords (aka model keywords)&#34;&#34;&#34;
    steps:list[IStep] = field(default_factory=list, init=False)
    &#34;&#34;&#34;List of all analysis steps&#34;&#34;&#34;

    def __post_init__(self):
        _gmsh.model.add(str(id(self)))
        self.mesh = msh.Mesh({},{},[],[])

    def clear_gmsh_model(self):
        &#34;&#34;&#34;Clears the gmsh model associated with this instance&#34;&#34;&#34;
        _gmsh.model.setCurrent(str(id(self)))
        _gmsh.model.remove()
        _gmsh.model.add(str(id(self)))

    def get_gmsh(self) -&gt; _gmsh:  # type: ignore
        &#34;&#34;&#34;Gets the Gmsh API with current model set to this instance&#34;&#34;&#34;
        _gmsh.model.setCurrent(str(id(self)))
        return _gmsh  # type: ignore

    def show_gmsh_gui(self):
        &#34;&#34;&#34;Shows the model in gmsh gui&#34;&#34;&#34;
        try: self.get_gmsh().fltk.run()
        except: pass

    def update_mesh_from_gmsh(self, type_mapping:Optional[dict[int, enums.EEtypes]]=None):
        &#34;&#34;&#34;
        Updates the mesh of this model from gmsh model. 
        Call this method every time you have made changes to the gmsh model 
        via gmsh gui or gmsh api.
        After the call, the mesh object of this model is updated (replaced).

        Important: 
        - Only solid elements are processed
        - Only nodes, elements and sets are processed which are in physical groups.
        - The mesh object of this model will be replaced by a new one.
          All changes since the last update (added nodes, surfaces etc.) will be lost.
        
        If type_mapping is omitted, the default mapping from gmsh element type number to ccx is:
        {4 : C3D4, 5 : C3D8I, 6 : C3D6, 11 : C3D10, 17 : C3D20R, 18 : C3D15}

        Args:
            type_mapping (dict[int, EEtypes], optional): A dictionary for mapping gmsh element type 
            numbers to ccx element type enums. If provided, it is used to update the default type mapping dict.
        &#34;&#34;&#34;
        
        self.mesh = msh.mesh_factory.mesh_from_gmsh(self.get_gmsh(), type_mapping)  # type: ignore

    def update_mesh_from_inp(self, filename:str, ignore_unsup_elems:bool=False, clear_mesh:bool=False):
        &#34;&#34;&#34;
        Updates the mesh of this model from the given *.inp file. 

        Only nodes, 3D solid elements, node- and element sets and surfaces will be read.

        If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
        If False, an ElementTypeNotSupportedError is raised if there are unsupported
        elements in the file.

        if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
        node ids and element faces which are not referred by any element are removed from every
        set and surface. If False, no clearing is done. 

        Args:
            filename (str): File name incl. path of ccx input file. 
            ignore_unsup_elems (bool, optional): Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError
        is raised if an unsupported solid element is processed. Defaults to False.
            ignore_unsup_elems (bool, optional): Flag if unsupported elements should be ignored. Defaults to False.
        
        &#34;&#34;&#34;
        self.mesh = msh.mesh_factory.mesh_from_inp(filename, ignore_unsup_elems, clear_mesh)

    def write_ccx_input_file(self):
        &#34;&#34;&#34;Writes the ccx input file &#39;jobname.inp&#39; to the working directory.&#34;&#34;&#34;

        buffer = []
        self.mesh.write_ccx(buffer)

        if self.model_keywords:
            buffer.append(&#39;&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;** MODEL KEYWORDS&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;&#39;)
            for mf in self.model_keywords:
                if mf.desc: buffer.append(f&#39;** {mf.desc}&#39;)
                buffer.append(str(mf))

        if self.steps:
            buffer.append(&#39;&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;** STEPS&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;&#39;)
            for step in self.steps:
                if step.desc: buffer.append(f&#39;** {step.desc}&#39;)
                buffer.append(str(step))
                for sf in step.step_keywords:
                    if sf.desc: buffer.append(f&#39;** {sf.desc}&#39;)
                    buffer.append(str(sf))
                buffer.append(&#39;*END STEP&#39;)

        filename = os.path.join(self.working_dir,  f&#39;{self.jobname}.inp&#39;)
        with open(filename, &#39;w&#39;) as f:
            f.writelines(f&#39;{s}\n&#39; for s in buffer)

    def add_model_keywords(self, *model_keywords:IKeyword):
        &#34;&#34;&#34;Adds the given model keywords to this model&#34;&#34;&#34;
        self.model_keywords.extend(model_keywords)

    def add_steps(self, *steps:IStep):
        &#34;&#34;&#34;Adds the given steps to this model&#34;&#34;&#34;
        self.steps.extend(steps)

    def show_model_in_cgx(self, write_ccx_input:bool=True):
        &#34;&#34;&#34;
        Shows the CCX input file in CGX.
        Per default, the input file is written before.

        Args:
            write_ccx_input (bool, optional): Flag if CCX input file should be written before opening CGX. Defaults to True.
        &#34;&#34;&#34;

        if  write_ccx_input: self.write_ccx_input_file()
        subprocess.run(f&#39;{self.cgx_path} -c &#34;{self.jobname}.inp&#34;&#39;, cwd=self.working_dir)

    def solve(self, write_ccx_input:bool=True, no_cpu:int=1):
        &#34;&#34;&#34;
        Starts CCX and solves the CCX input file.

        Args:
            write_ccx_input (bool, optional): Flag if CCX input file should be written before solve.
            Defaults to True.
            no_cpu (int, optional): Number of cpus used for solving. Defaults to 1.
            This parameter sets the local environment variable 
            OMP_NUM_THREADS to no_cpu
        &#34;&#34;&#34;
        if  write_ccx_input: self.write_ccx_input_file()
        env = {&#39;OMP_NUM_THREADS&#39;: str(no_cpu)}
        subprocess.run(f&#39;{self.ccx_path} -i &#34;{self.jobname}&#34;&#39;, cwd=self.working_dir, env=env)

    def show_results_in_cgx(self, load_inp:bool=True):
        &#34;&#34;&#34;
        Shows the results stored in the jobname.frd in CGX.
        
        If load_inp==True and the file jobname.inp is present in the working dir, it is
        loaded together with the frd.

        Args:
            load_inp (bool, optional): Flag if the inp file should be loaded with the 
            frd. Defaults to True.
        &#34;&#34;&#34;

        if load_inp and os.path.isfile(os.path.join(self.working_dir, self.jobname + &#39;.inp&#39;)):
            subprocess.run(f&#39;{self.cgx_path} &#34;{self.jobname}.frd&#34; &#34;{self.jobname}.inp&#34;&#39;, cwd=self.working_dir)
        else:
            subprocess.run(f&#39;{self.cgx_path} &#34;{self.jobname}.frd&#34;&#39;, cwd=self.working_dir)

    def get_frd_result(self) -&gt; FrdResult:
        &#34;&#34;&#34;
        Returns a frd result object from the jobname.frd

        Returns:
            FrdResult
        &#34;&#34;&#34;
        filename = os.path.join(self.working_dir, f&#39;{self.jobname}.frd&#39;)
        return FrdResult.from_file(filename)

    def get_dat_result(self) -&gt; DatResult:
        &#34;&#34;&#34;
        Returns a dat result object from the jobname.dat

        Returns:
            DatResult
        &#34;&#34;&#34;
        filename = os.path.join(self.working_dir, f&#39;{self.jobname}.dat&#39;)
        return DatResult.from_file(filename)

    def to_pickle(self):
        &#34;&#34;&#34;
        Serializes this model to a pickle file &#34;jobname.pkl&#34; in the working directory.
        Usefull for further post processing after the solve command.
        This way you can sepparate prepro, solve and postpro.

        Loading a model from a pickle file is much more save than loading from
        an inp file which causes loss of information.

        IMPORTANT: The gmsh model is not serialized!
        &#34;&#34;&#34;

        filename = os.path.join(self.working_dir,  f&#39;{self.jobname}.pkl&#39;)
        with open(filename, &#39;wb&#39;) as f:
            pickle.dump(self, f)

    @staticmethod
    def from_pickle(filename:str) -&gt; &#39;Model&#39;:
        &#34;&#34;&#34;Instanciates a model from the given pickle file.

        Args:
            filename (str): Filename incl. path to pickle file of the model to load. 

        Returns:
            Model: Deserialized Model

        Raises:
            TypeError: Raised if deserialized object is not a Model
        &#34;&#34;&#34;

        with open(filename, &#39;rb&#39;) as f:
            obj = pickle.load(f)
        if isinstance(obj, Model): return obj
        raise TypeError(&#34;Deserialized object is not of type Model.&#34;)

        
    

    def __enter__(self):
        return self
    def __exit__(self, type, value, traceback):
        self.get_gmsh().model.remove()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygccx.model.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>ccx_path: str, cgx_path: str, jobname: str = 'jobname', working_dir: str = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Model(ccx_path: str, cgx_path: str, jobname: str = 'jobname', working_dir: str = <factory>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Model:

    ccx_path:str
    &#34;&#34;&#34;Path to ccx executable&#34;&#34;&#34;
    cgx_path:str
    &#34;&#34;&#34;Path to cgx executable&#34;&#34;&#34;
    jobname:str = &#39;jobname&#39;
    &#34;&#34;&#34;Name of the job. All generated files will have this name.&#34;&#34;&#34;
    working_dir:str = field(default_factory=os.getcwd)
    &#34;&#34;&#34;Working directory where all generated files will be stored&#34;&#34;&#34;
    mesh:msh.Mesh = field(init=False)
    &#34;&#34;&#34;Mesh object of this model&#34;&#34;&#34;
    model_keywords:list[IKeyword] = field(default_factory=list, init=False)
    &#34;&#34;&#34;List of model keywords (aka model keywords)&#34;&#34;&#34;
    steps:list[IStep] = field(default_factory=list, init=False)
    &#34;&#34;&#34;List of all analysis steps&#34;&#34;&#34;

    def __post_init__(self):
        _gmsh.model.add(str(id(self)))
        self.mesh = msh.Mesh({},{},[],[])

    def clear_gmsh_model(self):
        &#34;&#34;&#34;Clears the gmsh model associated with this instance&#34;&#34;&#34;
        _gmsh.model.setCurrent(str(id(self)))
        _gmsh.model.remove()
        _gmsh.model.add(str(id(self)))

    def get_gmsh(self) -&gt; _gmsh:  # type: ignore
        &#34;&#34;&#34;Gets the Gmsh API with current model set to this instance&#34;&#34;&#34;
        _gmsh.model.setCurrent(str(id(self)))
        return _gmsh  # type: ignore

    def show_gmsh_gui(self):
        &#34;&#34;&#34;Shows the model in gmsh gui&#34;&#34;&#34;
        try: self.get_gmsh().fltk.run()
        except: pass

    def update_mesh_from_gmsh(self, type_mapping:Optional[dict[int, enums.EEtypes]]=None):
        &#34;&#34;&#34;
        Updates the mesh of this model from gmsh model. 
        Call this method every time you have made changes to the gmsh model 
        via gmsh gui or gmsh api.
        After the call, the mesh object of this model is updated (replaced).

        Important: 
        - Only solid elements are processed
        - Only nodes, elements and sets are processed which are in physical groups.
        - The mesh object of this model will be replaced by a new one.
          All changes since the last update (added nodes, surfaces etc.) will be lost.
        
        If type_mapping is omitted, the default mapping from gmsh element type number to ccx is:
        {4 : C3D4, 5 : C3D8I, 6 : C3D6, 11 : C3D10, 17 : C3D20R, 18 : C3D15}

        Args:
            type_mapping (dict[int, EEtypes], optional): A dictionary for mapping gmsh element type 
            numbers to ccx element type enums. If provided, it is used to update the default type mapping dict.
        &#34;&#34;&#34;
        
        self.mesh = msh.mesh_factory.mesh_from_gmsh(self.get_gmsh(), type_mapping)  # type: ignore

    def update_mesh_from_inp(self, filename:str, ignore_unsup_elems:bool=False, clear_mesh:bool=False):
        &#34;&#34;&#34;
        Updates the mesh of this model from the given *.inp file. 

        Only nodes, 3D solid elements, node- and element sets and surfaces will be read.

        If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
        If False, an ElementTypeNotSupportedError is raised if there are unsupported
        elements in the file.

        if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
        node ids and element faces which are not referred by any element are removed from every
        set and surface. If False, no clearing is done. 

        Args:
            filename (str): File name incl. path of ccx input file. 
            ignore_unsup_elems (bool, optional): Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError
        is raised if an unsupported solid element is processed. Defaults to False.
            ignore_unsup_elems (bool, optional): Flag if unsupported elements should be ignored. Defaults to False.
        
        &#34;&#34;&#34;
        self.mesh = msh.mesh_factory.mesh_from_inp(filename, ignore_unsup_elems, clear_mesh)

    def write_ccx_input_file(self):
        &#34;&#34;&#34;Writes the ccx input file &#39;jobname.inp&#39; to the working directory.&#34;&#34;&#34;

        buffer = []
        self.mesh.write_ccx(buffer)

        if self.model_keywords:
            buffer.append(&#39;&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;** MODEL KEYWORDS&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;&#39;)
            for mf in self.model_keywords:
                if mf.desc: buffer.append(f&#39;** {mf.desc}&#39;)
                buffer.append(str(mf))

        if self.steps:
            buffer.append(&#39;&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;** STEPS&#39;)
            buffer.append(&#39;***************************************&#39;)
            buffer.append(&#39;&#39;)
            for step in self.steps:
                if step.desc: buffer.append(f&#39;** {step.desc}&#39;)
                buffer.append(str(step))
                for sf in step.step_keywords:
                    if sf.desc: buffer.append(f&#39;** {sf.desc}&#39;)
                    buffer.append(str(sf))
                buffer.append(&#39;*END STEP&#39;)

        filename = os.path.join(self.working_dir,  f&#39;{self.jobname}.inp&#39;)
        with open(filename, &#39;w&#39;) as f:
            f.writelines(f&#39;{s}\n&#39; for s in buffer)

    def add_model_keywords(self, *model_keywords:IKeyword):
        &#34;&#34;&#34;Adds the given model keywords to this model&#34;&#34;&#34;
        self.model_keywords.extend(model_keywords)

    def add_steps(self, *steps:IStep):
        &#34;&#34;&#34;Adds the given steps to this model&#34;&#34;&#34;
        self.steps.extend(steps)

    def show_model_in_cgx(self, write_ccx_input:bool=True):
        &#34;&#34;&#34;
        Shows the CCX input file in CGX.
        Per default, the input file is written before.

        Args:
            write_ccx_input (bool, optional): Flag if CCX input file should be written before opening CGX. Defaults to True.
        &#34;&#34;&#34;

        if  write_ccx_input: self.write_ccx_input_file()
        subprocess.run(f&#39;{self.cgx_path} -c &#34;{self.jobname}.inp&#34;&#39;, cwd=self.working_dir)

    def solve(self, write_ccx_input:bool=True, no_cpu:int=1):
        &#34;&#34;&#34;
        Starts CCX and solves the CCX input file.

        Args:
            write_ccx_input (bool, optional): Flag if CCX input file should be written before solve.
            Defaults to True.
            no_cpu (int, optional): Number of cpus used for solving. Defaults to 1.
            This parameter sets the local environment variable 
            OMP_NUM_THREADS to no_cpu
        &#34;&#34;&#34;
        if  write_ccx_input: self.write_ccx_input_file()
        env = {&#39;OMP_NUM_THREADS&#39;: str(no_cpu)}
        subprocess.run(f&#39;{self.ccx_path} -i &#34;{self.jobname}&#34;&#39;, cwd=self.working_dir, env=env)

    def show_results_in_cgx(self, load_inp:bool=True):
        &#34;&#34;&#34;
        Shows the results stored in the jobname.frd in CGX.
        
        If load_inp==True and the file jobname.inp is present in the working dir, it is
        loaded together with the frd.

        Args:
            load_inp (bool, optional): Flag if the inp file should be loaded with the 
            frd. Defaults to True.
        &#34;&#34;&#34;

        if load_inp and os.path.isfile(os.path.join(self.working_dir, self.jobname + &#39;.inp&#39;)):
            subprocess.run(f&#39;{self.cgx_path} &#34;{self.jobname}.frd&#34; &#34;{self.jobname}.inp&#34;&#39;, cwd=self.working_dir)
        else:
            subprocess.run(f&#39;{self.cgx_path} &#34;{self.jobname}.frd&#34;&#39;, cwd=self.working_dir)

    def get_frd_result(self) -&gt; FrdResult:
        &#34;&#34;&#34;
        Returns a frd result object from the jobname.frd

        Returns:
            FrdResult
        &#34;&#34;&#34;
        filename = os.path.join(self.working_dir, f&#39;{self.jobname}.frd&#39;)
        return FrdResult.from_file(filename)

    def get_dat_result(self) -&gt; DatResult:
        &#34;&#34;&#34;
        Returns a dat result object from the jobname.dat

        Returns:
            DatResult
        &#34;&#34;&#34;
        filename = os.path.join(self.working_dir, f&#39;{self.jobname}.dat&#39;)
        return DatResult.from_file(filename)

    def to_pickle(self):
        &#34;&#34;&#34;
        Serializes this model to a pickle file &#34;jobname.pkl&#34; in the working directory.
        Usefull for further post processing after the solve command.
        This way you can sepparate prepro, solve and postpro.

        Loading a model from a pickle file is much more save than loading from
        an inp file which causes loss of information.

        IMPORTANT: The gmsh model is not serialized!
        &#34;&#34;&#34;

        filename = os.path.join(self.working_dir,  f&#39;{self.jobname}.pkl&#39;)
        with open(filename, &#39;wb&#39;) as f:
            pickle.dump(self, f)

    @staticmethod
    def from_pickle(filename:str) -&gt; &#39;Model&#39;:
        &#34;&#34;&#34;Instanciates a model from the given pickle file.

        Args:
            filename (str): Filename incl. path to pickle file of the model to load. 

        Returns:
            Model: Deserialized Model

        Raises:
            TypeError: Raised if deserialized object is not a Model
        &#34;&#34;&#34;

        with open(filename, &#39;rb&#39;) as f:
            obj = pickle.load(f)
        if isinstance(obj, Model): return obj
        raise TypeError(&#34;Deserialized object is not of type Model.&#34;)

        
    

    def __enter__(self):
        return self
    def __exit__(self, type, value, traceback):
        self.get_gmsh().model.remove()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pygccx.model.Model.ccx_path"><code class="name">var <span class="ident">ccx_path</span> : str</code></dt>
<dd>
<div class="desc"><p>Path to ccx executable</p></div>
</dd>
<dt id="pygccx.model.Model.cgx_path"><code class="name">var <span class="ident">cgx_path</span> : str</code></dt>
<dd>
<div class="desc"><p>Path to cgx executable</p></div>
</dd>
<dt id="pygccx.model.Model.jobname"><code class="name">var <span class="ident">jobname</span> : str</code></dt>
<dd>
<div class="desc"><p>Name of the job. All generated files will have this name.</p></div>
</dd>
<dt id="pygccx.model.Model.mesh"><code class="name">var <span class="ident">mesh</span> : <a title="pygccx.mesh.mesh.Mesh" href="mesh/mesh.html#pygccx.mesh.mesh.Mesh">Mesh</a></code></dt>
<dd>
<div class="desc"><p>Mesh object of this model</p></div>
</dd>
<dt id="pygccx.model.Model.model_keywords"><code class="name">var <span class="ident">model_keywords</span> : list[<a title="pygccx.protocols.IKeyword" href="protocols.html#pygccx.protocols.IKeyword">IKeyword</a>]</code></dt>
<dd>
<div class="desc"><p>List of model keywords (aka model keywords)</p></div>
</dd>
<dt id="pygccx.model.Model.steps"><code class="name">var <span class="ident">steps</span> : list[<a title="pygccx.protocols.IStep" href="protocols.html#pygccx.protocols.IStep">IStep</a>]</code></dt>
<dd>
<div class="desc"><p>List of all analysis steps</p></div>
</dd>
<dt id="pygccx.model.Model.working_dir"><code class="name">var <span class="ident">working_dir</span> : str</code></dt>
<dd>
<div class="desc"><p>Working directory where all generated files will be stored</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pygccx.model.Model.from_pickle"><code class="name flex">
<span>def <span class="ident">from_pickle</span></span>(<span>filename: str) ‑> <a title="pygccx.model.Model" href="#pygccx.model.Model">Model</a></span>
</code></dt>
<dd>
<div class="desc"><p>Instanciates a model from the given pickle file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename incl. path to pickle file of the model to load. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pygccx.model.Model" href="#pygccx.model.Model">Model</a></code></dt>
<dd>Deserialized Model</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised if deserialized object is not a Model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pickle(filename:str) -&gt; &#39;Model&#39;:
    &#34;&#34;&#34;Instanciates a model from the given pickle file.

    Args:
        filename (str): Filename incl. path to pickle file of the model to load. 

    Returns:
        Model: Deserialized Model

    Raises:
        TypeError: Raised if deserialized object is not a Model
    &#34;&#34;&#34;

    with open(filename, &#39;rb&#39;) as f:
        obj = pickle.load(f)
    if isinstance(obj, Model): return obj
    raise TypeError(&#34;Deserialized object is not of type Model.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygccx.model.Model.add_model_keywords"><code class="name flex">
<span>def <span class="ident">add_model_keywords</span></span>(<span>self, *model_keywords: <a title="pygccx.protocols.IKeyword" href="protocols.html#pygccx.protocols.IKeyword">IKeyword</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the given model keywords to this model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_model_keywords(self, *model_keywords:IKeyword):
    &#34;&#34;&#34;Adds the given model keywords to this model&#34;&#34;&#34;
    self.model_keywords.extend(model_keywords)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.add_steps"><code class="name flex">
<span>def <span class="ident">add_steps</span></span>(<span>self, *steps: <a title="pygccx.protocols.IStep" href="protocols.html#pygccx.protocols.IStep">IStep</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the given steps to this model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_steps(self, *steps:IStep):
    &#34;&#34;&#34;Adds the given steps to this model&#34;&#34;&#34;
    self.steps.extend(steps)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.clear_gmsh_model"><code class="name flex">
<span>def <span class="ident">clear_gmsh_model</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the gmsh model associated with this instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_gmsh_model(self):
    &#34;&#34;&#34;Clears the gmsh model associated with this instance&#34;&#34;&#34;
    _gmsh.model.setCurrent(str(id(self)))
    _gmsh.model.remove()
    _gmsh.model.add(str(id(self)))</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.get_dat_result"><code class="name flex">
<span>def <span class="ident">get_dat_result</span></span>(<span>self) ‑> <a title="pygccx.result_reader.dat_result.DatResult" href="result_reader/dat_result.html#pygccx.result_reader.dat_result.DatResult">DatResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dat result object from the jobname.dat</p>
<h2 id="returns">Returns</h2>
<p>DatResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dat_result(self) -&gt; DatResult:
    &#34;&#34;&#34;
    Returns a dat result object from the jobname.dat

    Returns:
        DatResult
    &#34;&#34;&#34;
    filename = os.path.join(self.working_dir, f&#39;{self.jobname}.dat&#39;)
    return DatResult.from_file(filename)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.get_frd_result"><code class="name flex">
<span>def <span class="ident">get_frd_result</span></span>(<span>self) ‑> <a title="pygccx.result_reader.frd_result.FrdResult" href="result_reader/frd_result.html#pygccx.result_reader.frd_result.FrdResult">FrdResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a frd result object from the jobname.frd</p>
<h2 id="returns">Returns</h2>
<p>FrdResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frd_result(self) -&gt; FrdResult:
    &#34;&#34;&#34;
    Returns a frd result object from the jobname.frd

    Returns:
        FrdResult
    &#34;&#34;&#34;
    filename = os.path.join(self.working_dir, f&#39;{self.jobname}.frd&#39;)
    return FrdResult.from_file(filename)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.get_gmsh"><code class="name flex">
<span>def <span class="ident">get_gmsh</span></span>(<span>self) ‑> <module 'gmsh' from 'D:\\GitHub\\pygccx_project\\venv310\\lib\\site-packages\\gmsh.py'></span>
</code></dt>
<dd>
<div class="desc"><p>Gets the Gmsh API with current model set to this instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gmsh(self) -&gt; _gmsh:  # type: ignore
    &#34;&#34;&#34;Gets the Gmsh API with current model set to this instance&#34;&#34;&#34;
    _gmsh.model.setCurrent(str(id(self)))
    return _gmsh  # type: ignore</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.show_gmsh_gui"><code class="name flex">
<span>def <span class="ident">show_gmsh_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the model in gmsh gui</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_gmsh_gui(self):
    &#34;&#34;&#34;Shows the model in gmsh gui&#34;&#34;&#34;
    try: self.get_gmsh().fltk.run()
    except: pass</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.show_model_in_cgx"><code class="name flex">
<span>def <span class="ident">show_model_in_cgx</span></span>(<span>self, write_ccx_input: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the CCX input file in CGX.
Per default, the input file is written before.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>write_ccx_input</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag if CCX input file should be written before opening CGX. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_model_in_cgx(self, write_ccx_input:bool=True):
    &#34;&#34;&#34;
    Shows the CCX input file in CGX.
    Per default, the input file is written before.

    Args:
        write_ccx_input (bool, optional): Flag if CCX input file should be written before opening CGX. Defaults to True.
    &#34;&#34;&#34;

    if  write_ccx_input: self.write_ccx_input_file()
    subprocess.run(f&#39;{self.cgx_path} -c &#34;{self.jobname}.inp&#34;&#39;, cwd=self.working_dir)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.show_results_in_cgx"><code class="name flex">
<span>def <span class="ident">show_results_in_cgx</span></span>(<span>self, load_inp: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the results stored in the jobname.frd in CGX.</p>
<p>If load_inp==True and the file jobname.inp is present in the working dir, it is
loaded together with the frd.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>load_inp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag if the inp file should be loaded with the </dd>
</dl>
<p>frd. Defaults to True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_results_in_cgx(self, load_inp:bool=True):
    &#34;&#34;&#34;
    Shows the results stored in the jobname.frd in CGX.
    
    If load_inp==True and the file jobname.inp is present in the working dir, it is
    loaded together with the frd.

    Args:
        load_inp (bool, optional): Flag if the inp file should be loaded with the 
        frd. Defaults to True.
    &#34;&#34;&#34;

    if load_inp and os.path.isfile(os.path.join(self.working_dir, self.jobname + &#39;.inp&#39;)):
        subprocess.run(f&#39;{self.cgx_path} &#34;{self.jobname}.frd&#34; &#34;{self.jobname}.inp&#34;&#39;, cwd=self.working_dir)
    else:
        subprocess.run(f&#39;{self.cgx_path} &#34;{self.jobname}.frd&#34;&#39;, cwd=self.working_dir)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, write_ccx_input: bool = True, no_cpu: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts CCX and solves the CCX input file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>write_ccx_input</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag if CCX input file should be written before solve.</dd>
<dt>Defaults to True.</dt>
<dt><strong><code>no_cpu</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of cpus used for solving. Defaults to 1.</dd>
</dl>
<p>This parameter sets the local environment variable
OMP_NUM_THREADS to no_cpu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, write_ccx_input:bool=True, no_cpu:int=1):
    &#34;&#34;&#34;
    Starts CCX and solves the CCX input file.

    Args:
        write_ccx_input (bool, optional): Flag if CCX input file should be written before solve.
        Defaults to True.
        no_cpu (int, optional): Number of cpus used for solving. Defaults to 1.
        This parameter sets the local environment variable 
        OMP_NUM_THREADS to no_cpu
    &#34;&#34;&#34;
    if  write_ccx_input: self.write_ccx_input_file()
    env = {&#39;OMP_NUM_THREADS&#39;: str(no_cpu)}
    subprocess.run(f&#39;{self.ccx_path} -i &#34;{self.jobname}&#34;&#39;, cwd=self.working_dir, env=env)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.to_pickle"><code class="name flex">
<span>def <span class="ident">to_pickle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Serializes this model to a pickle file "jobname.pkl" in the working directory.
Usefull for further post processing after the solve command.
This way you can sepparate prepro, solve and postpro.</p>
<p>Loading a model from a pickle file is much more save than loading from
an inp file which causes loss of information.</p>
<p>IMPORTANT: The gmsh model is not serialized!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pickle(self):
    &#34;&#34;&#34;
    Serializes this model to a pickle file &#34;jobname.pkl&#34; in the working directory.
    Usefull for further post processing after the solve command.
    This way you can sepparate prepro, solve and postpro.

    Loading a model from a pickle file is much more save than loading from
    an inp file which causes loss of information.

    IMPORTANT: The gmsh model is not serialized!
    &#34;&#34;&#34;

    filename = os.path.join(self.working_dir,  f&#39;{self.jobname}.pkl&#39;)
    with open(filename, &#39;wb&#39;) as f:
        pickle.dump(self, f)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.update_mesh_from_gmsh"><code class="name flex">
<span>def <span class="ident">update_mesh_from_gmsh</span></span>(<span>self, type_mapping: Optional[dict[int, <a title="pygccx.enums.EEtypes" href="enums.html#pygccx.enums.EEtypes">EEtypes</a>]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the mesh of this model from gmsh model.
Call this method every time you have made changes to the gmsh model
via gmsh gui or gmsh api.
After the call, the mesh object of this model is updated (replaced).</p>
<p>Important:
- Only solid elements are processed
- Only nodes, elements and sets are processed which are in physical groups.
- The mesh object of this model will be replaced by a new one.
All changes since the last update (added nodes, surfaces etc.) will be lost.</p>
<p 11 17 18 4 5 6 : C3D10_="C3D10," C3D15 C3D20R_="C3D20R," C3D4_="C3D4," C3D6_="C3D6," C3D8I_="C3D8I,">If type_mapping is omitted, the default mapping from gmsh element type number to ccx is:</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_mapping</code></strong> :&ensp;<code>dict[int, EEtypes]</code>, optional</dt>
<dd>A dictionary for mapping gmsh element type </dd>
</dl>
<p>numbers to ccx element type enums. If provided, it is used to update the default type mapping dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mesh_from_gmsh(self, type_mapping:Optional[dict[int, enums.EEtypes]]=None):
    &#34;&#34;&#34;
    Updates the mesh of this model from gmsh model. 
    Call this method every time you have made changes to the gmsh model 
    via gmsh gui or gmsh api.
    After the call, the mesh object of this model is updated (replaced).

    Important: 
    - Only solid elements are processed
    - Only nodes, elements and sets are processed which are in physical groups.
    - The mesh object of this model will be replaced by a new one.
      All changes since the last update (added nodes, surfaces etc.) will be lost.
    
    If type_mapping is omitted, the default mapping from gmsh element type number to ccx is:
    {4 : C3D4, 5 : C3D8I, 6 : C3D6, 11 : C3D10, 17 : C3D20R, 18 : C3D15}

    Args:
        type_mapping (dict[int, EEtypes], optional): A dictionary for mapping gmsh element type 
        numbers to ccx element type enums. If provided, it is used to update the default type mapping dict.
    &#34;&#34;&#34;
    
    self.mesh = msh.mesh_factory.mesh_from_gmsh(self.get_gmsh(), type_mapping)  # type: ignore</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.update_mesh_from_inp"><code class="name flex">
<span>def <span class="ident">update_mesh_from_inp</span></span>(<span>self, filename: str, ignore_unsup_elems: bool = False, clear_mesh: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the mesh of this model from the given *.inp file. </p>
<p>Only nodes, 3D solid elements, node- and element sets and surfaces will be read.</p>
<p>If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
If False, an ElementTypeNotSupportedError is raised if there are unsupported
elements in the file.</p>
<p>if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
node ids and element faces which are not referred by any element are removed from every
set and surface. If False, no clearing is done. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>File name incl. path of ccx input file. </dd>
<dt><strong><code>ignore_unsup_elems</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError</dd>
</dl>
<p>is raised if an unsupported solid element is processed. Defaults to False.
ignore_unsup_elems (bool, optional): Flag if unsupported elements should be ignored. Defaults to False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mesh_from_inp(self, filename:str, ignore_unsup_elems:bool=False, clear_mesh:bool=False):
    &#34;&#34;&#34;
    Updates the mesh of this model from the given *.inp file. 

    Only nodes, 3D solid elements, node- and element sets and surfaces will be read.

    If ignore_unsup_elems==True element blocks with unsupported elements (i.e. beam, shell) are skipped.
    If False, an ElementTypeNotSupportedError is raised if there are unsupported
    elements in the file.

    if clear_mesh==True the resulting mesh object is cleared. This means all element ids,
    node ids and element faces which are not referred by any element are removed from every
    set and surface. If False, no clearing is done. 

    Args:
        filename (str): File name incl. path of ccx input file. 
        ignore_unsup_elems (bool, optional): Flag if unsupported elements should be skipped. If False, an ElementTypeNotSupportedError
    is raised if an unsupported solid element is processed. Defaults to False.
        ignore_unsup_elems (bool, optional): Flag if unsupported elements should be ignored. Defaults to False.
    
    &#34;&#34;&#34;
    self.mesh = msh.mesh_factory.mesh_from_inp(filename, ignore_unsup_elems, clear_mesh)</code></pre>
</details>
</dd>
<dt id="pygccx.model.Model.write_ccx_input_file"><code class="name flex">
<span>def <span class="ident">write_ccx_input_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the ccx input file 'jobname.inp' to the working directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_ccx_input_file(self):
    &#34;&#34;&#34;Writes the ccx input file &#39;jobname.inp&#39; to the working directory.&#34;&#34;&#34;

    buffer = []
    self.mesh.write_ccx(buffer)

    if self.model_keywords:
        buffer.append(&#39;&#39;)
        buffer.append(&#39;***************************************&#39;)
        buffer.append(&#39;** MODEL KEYWORDS&#39;)
        buffer.append(&#39;***************************************&#39;)
        buffer.append(&#39;&#39;)
        for mf in self.model_keywords:
            if mf.desc: buffer.append(f&#39;** {mf.desc}&#39;)
            buffer.append(str(mf))

    if self.steps:
        buffer.append(&#39;&#39;)
        buffer.append(&#39;***************************************&#39;)
        buffer.append(&#39;** STEPS&#39;)
        buffer.append(&#39;***************************************&#39;)
        buffer.append(&#39;&#39;)
        for step in self.steps:
            if step.desc: buffer.append(f&#39;** {step.desc}&#39;)
            buffer.append(str(step))
            for sf in step.step_keywords:
                if sf.desc: buffer.append(f&#39;** {sf.desc}&#39;)
                buffer.append(str(sf))
            buffer.append(&#39;*END STEP&#39;)

    filename = os.path.join(self.working_dir,  f&#39;{self.jobname}.inp&#39;)
    with open(filename, &#39;w&#39;) as f:
        f.writelines(f&#39;{s}\n&#39; for s in buffer)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygccx" href="index.html">pygccx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygccx.model.Model" href="#pygccx.model.Model">Model</a></code></h4>
<ul class="">
<li><code><a title="pygccx.model.Model.add_model_keywords" href="#pygccx.model.Model.add_model_keywords">add_model_keywords</a></code></li>
<li><code><a title="pygccx.model.Model.add_steps" href="#pygccx.model.Model.add_steps">add_steps</a></code></li>
<li><code><a title="pygccx.model.Model.ccx_path" href="#pygccx.model.Model.ccx_path">ccx_path</a></code></li>
<li><code><a title="pygccx.model.Model.cgx_path" href="#pygccx.model.Model.cgx_path">cgx_path</a></code></li>
<li><code><a title="pygccx.model.Model.clear_gmsh_model" href="#pygccx.model.Model.clear_gmsh_model">clear_gmsh_model</a></code></li>
<li><code><a title="pygccx.model.Model.from_pickle" href="#pygccx.model.Model.from_pickle">from_pickle</a></code></li>
<li><code><a title="pygccx.model.Model.get_dat_result" href="#pygccx.model.Model.get_dat_result">get_dat_result</a></code></li>
<li><code><a title="pygccx.model.Model.get_frd_result" href="#pygccx.model.Model.get_frd_result">get_frd_result</a></code></li>
<li><code><a title="pygccx.model.Model.get_gmsh" href="#pygccx.model.Model.get_gmsh">get_gmsh</a></code></li>
<li><code><a title="pygccx.model.Model.jobname" href="#pygccx.model.Model.jobname">jobname</a></code></li>
<li><code><a title="pygccx.model.Model.mesh" href="#pygccx.model.Model.mesh">mesh</a></code></li>
<li><code><a title="pygccx.model.Model.model_keywords" href="#pygccx.model.Model.model_keywords">model_keywords</a></code></li>
<li><code><a title="pygccx.model.Model.show_gmsh_gui" href="#pygccx.model.Model.show_gmsh_gui">show_gmsh_gui</a></code></li>
<li><code><a title="pygccx.model.Model.show_model_in_cgx" href="#pygccx.model.Model.show_model_in_cgx">show_model_in_cgx</a></code></li>
<li><code><a title="pygccx.model.Model.show_results_in_cgx" href="#pygccx.model.Model.show_results_in_cgx">show_results_in_cgx</a></code></li>
<li><code><a title="pygccx.model.Model.solve" href="#pygccx.model.Model.solve">solve</a></code></li>
<li><code><a title="pygccx.model.Model.steps" href="#pygccx.model.Model.steps">steps</a></code></li>
<li><code><a title="pygccx.model.Model.to_pickle" href="#pygccx.model.Model.to_pickle">to_pickle</a></code></li>
<li><code><a title="pygccx.model.Model.update_mesh_from_gmsh" href="#pygccx.model.Model.update_mesh_from_gmsh">update_mesh_from_gmsh</a></code></li>
<li><code><a title="pygccx.model.Model.update_mesh_from_inp" href="#pygccx.model.Model.update_mesh_from_inp">update_mesh_from_inp</a></code></li>
<li><code><a title="pygccx.model.Model.working_dir" href="#pygccx.model.Model.working_dir">working_dir</a></code></li>
<li><code><a title="pygccx.model.Model.write_ccx_input_file" href="#pygccx.model.Model.write_ccx_input_file">write_ccx_input_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>